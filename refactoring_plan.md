# リファクタリング計画：auto_strategy と indicators

## 目的

本ドキュメントは、`backend/app/core/services/auto_strategy` および `backend/app/core/services/indicators` ディレクトリ内のコードベースにおける重複、冗長性、および責務の不明確な箇所を特定し、それらに対するリファクタリング案を提示することを目的とします。これにより、コードの可読性、保守性、拡張性を向上させます。

## 概要

以下の主要なリファクタリング領域を特定しました。

2.  **`IndicatorCalculator` の計算ロジックの合理化**
3.  **`IndicatorCalculator` 内のパラメータハンドリングの洗練** (セクション 2 に統合)
4.  **OI/FR データソースのハードコードされたフォールバック値の見直し**
5.  **指標インスタンス作成とパラメータバリデーションの調和**

---

## 2. `IndicatorCalculator` の計算ロジックの合理化

### 現状の課題

`IndicatorCalculator` クラスは、指標の計算ロジックにおいて冗長性や複雑さを抱えています。特に、`_setup_indicator_config` での新旧設定の混在、`calculate_indicator` 内の `_calculate_from_config` と `_calculate_from_adapter` という二つの計算パス、そして `_calculate_from_adapter` 内でのパラメータの手動再解釈が主な課題です。

- `backend/app/core/services/auto_strategy/factories/indicator_calculator.py`:
  - `_setup_indicator_config` メソッドは、`indicator_registry` からの `IndicatorConfig` インスタンスと、ハードコードされたレガシー設定の両方を `self.indicator_config` に格納しています。これにより、設定管理が複雑になっています。
  - `calculate_indicator` メソッドは、`indicator_type` が `self.indicator_config` に存在するかどうかで処理を分岐させ、`_calculate_from_config` または `_calculate_from_adapter` を呼び出しています。
  - `_calculate_from_adapter` メソッドは、特定の指標タイプ（SMA, EMA, RSI など）に対してパラメータを手動で再解釈しており、これは `IndicatorConfig` の `parameters` 定義との重複や不整合を生む可能性があります。このメソッドは冗長であり、`IndicatorConfig` を中心とした設計に反しています。
  - `_prepare_parameters_for_indicator` メソッドは、新しい JSON 形式の設定とレガシー形式の設定の両方を扱っていますが、`IndicatorConfig` の `parameters` 定義に完全に依存するように強化する必要があります。
  - `_generate_indicator_name` というメソッドは存在しません。
  - `_handle_complex_result` は `config["indicator_config"].generate_json_name()` を使用しており、これは適切です。しかし、`macd_handler` と `bb_handler` のロジックはハードコードされており、`IndicatorConfig` の `result_handler` をより汎用的に活用できる可能性があります。

これにより、以下の問題が発生しています。

- **ロジックの複雑性**: 2 つの計算パスが存在するため、コードの理解とデバッグが困難です。
- **設定の一貫性の欠如**: JSON 形式への移行が中途半端なため、新旧の設定が混在し、将来的な拡張が難しくなっています。
- **冗長なパラメータハンドリング**: `_calculate_from_adapter` でパラメータを再度解析している部分が冗長です。

### 提案

`IndicatorCalculator` の計算ロジックを合理化し、`IndicatorConfig` を中心とした単一の、より明確なフローに統合することを提案します。これにより、JSON 形式の指標設定を完全に活用し、レガシー互換性をより適切に管理できます。

**変更案の概要:**

1.  **`_setup_indicator_config` の合理化**:
    - `self.indicator_config` には `indicator_registry` から取得した `IndicatorConfig` インスタンスのみを格納するように変更します。レガシー設定のフォールバックは `indicator_registry` または `IndicatorConfig` 自体で処理されるべきです。
    - `_get_legacy_config` メソッドは削除します。
2.  **`_setup_indicator_adapters` の役割の明確化**:
    - このメソッドは、`IndicatorConfig` 内の `adapter_function` フィールドへの参照を提供する役割に限定します。`indicator_registry` から `IndicatorConfig` を取得し、その `adapter_function` を直接使用するように変更します。
3.  **単一の計算フローへの統合**:
    - `calculate_indicator` メソッド内で、直接 `self.indicator_config` を参照し、対応する `adapter_function` と `IndicatorConfig` から取得したパラメータ情報を使用して計算を実行します。
    - `_calculate_from_adapter` メソッドを完全に削除します。
    - `_calculate_from_config` のロジックを `calculate_indicator` に統合し、`_prepare_data_for_indicator` と `_prepare_parameters_for_indicator` を活用して統一されたデータとパラメータの渡し方を実現します。
4.  **`_prepare_parameters_for_indicator` の強化**:
    - このメソッドを強化し、`IndicatorConfig` の `parameters` 定義に完全に依存してパラメータを準備するようにします。これにより、手動でのパラメータ解析が不要になります。
5.  **`_generate_indicator_name` への言及の削除**:
    - `_generate_indicator_name` というメソッドは存在しないため、コード内のその言及を削除します。
6.  **`_handle_complex_result` の改善**:
    - `IndicatorConfig` で定義された `result_handler` に基づいて、計算結果から適切な値を抽出するロジックを保持します。必要に応じて、`result_handler` の種類を拡張し、より汎用的な処理を可能にします。

**期待される効果:**

- **コードの簡素化**: 計算ロジックが単一の明確なパスに統合され、コードベースが大幅に簡素化されます。
- **保守性の向上**: 指標の計算ロジックが一元化されるため、バグ修正や機能追加が容易になります。
- **JSON 形式の完全活用**: `IndicatorConfig` に定義された JSON 形式の情報を最大限に活用し、設定とロジックの一貫性が向上します。
- **パフォーマンスの可能性**: 不要な条件分岐や再解析が減ることで、わずかながらパフォーマンスの改善が期待できます。

---



## 4. 指標インスタンス作成とパラメータバリデーションの調和

### 現状の課題

当初、`backend/app/core/services/indicators/factories/indicator_factory.py` に `IndicatorFactory` クラスが存在し、`backend/app/core/services/auto_strategy/factories/indicator_initializer.py` との間で指標インスタンス作成とパラメータバリデーションロジックが重複していると推測していました。

しかし、その後の調査で `IndicatorFactory` というクラスは現在のコードベースには存在しないことが判明しました。

現在のところ、指標のインスタンス作成と初期化は主に `backend/app/core/services/auto_strategy/factories/indicator_initializer.py` および `backend/app/core/services/auto_strategy/factories/indicator_calculator.py` で行われているようです。具体的には以下の課題が見られます。

- `indicator_initializer.py` の `initialize_indicator` メソッドが、`IndicatorCalculator` を呼び出して指標の計算と結果取得を行っています。
- `_create_indicator_instance` のような直接的なインスタンス生成ロジックは `indicator_initializer.py` にはありませんが、`calculate_indicator_only` メソッドが `IndicatorCalculator` を直接利用しています。
- パラメータのバリデーションは、`IndicatorConfig` に定義があるにも関わらず、呼び出し側で一貫して適用されているか不明確です。

これにより、以下の問題が発生しています。

- **ロジックの分散**: 指標インスタンスの作成とパラメータバリデーションに関する責任が、`IndicatorInitializer` と `IndicatorCalculator` の間で明確に分かれていない可能性があります。
- **バリデーションの不透明性**: パラメータがどこで、どのようにバリデーションされているかが一貫していません。
- **保守性の低下**: 指標の追加や変更時に、複数のファイルを修正する必要があり、エラーのリスクが高まります。
- **責務の不明確さ**: どのモジュールが指標のインスタンス作成とパラメータバリデーションの主要な責務を持つべきかが不明確です。

### 提案

指標のインスタンス作成とパラメータバリデーションのロジックを、指標の「初期化」と「計算」という役割分担に基づき、より明確に責任を割り当てることを提案します。`IndicatorInitializer` を指標のセットアップと `backtesting.py` 戦略インスタンスへの統合に特化させ、`IndicatorCalculator` は純粋に指標の計算ロジックに集中させます。

**変更案の概要:**

1.  **`IndicatorInitializer` を指標のセットアップと統合に特化**:
    - `initialize_indicator` メソッド内で、`IndicatorConfig` を参照し、その情報に基づいて必要なデータ準備とパラメータのバリデーションを行います。
    - パラメータのバリデーションには、「1. パラメータ生成とバリデーションの一元化」で提案した `ParameterService` を利用することを検討します。
    - バリデーション済みのデータとパラメータを `IndicatorCalculator` に渡し、計算結果を受け取ります。
    - 計算結果を `backtesting.py` の戦略インスタンスに適切に統合する責務を担います。
2.  **`IndicatorCalculator` は純粋な計算ロジックに集中**:
    - 「4. `IndicatorCalculator` の計算ロジックの合理化」の提案に基づき、`IndicatorConfig` を唯一の情報源として計算を実行します。
    - パラメータのバリデーションは `IndicatorInitializer` が実施し、`IndicatorCalculator` にはバリデーション済みのパラメータが渡されることを前提とします。
3.  **パラメータバリデーションの一元化と強制**:
    - 全ての指標インスタンス作成（または計算開始前）において、`ParameterService` を介してパラメータのバリデーションを強制します。これにより、不正なパラメータが指標計算に渡されることを防ぎます。

**期待される効果:**

- **単一責任の原則**: 各モジュールの責務が明確になり、コードの品質が向上します。
- **一貫したバリデーション**: パラメータのバリデーションが強制され、不正なデータによるエラーを防ぎます。
- **保守性の向上**: 指標の追加や変更が容易になり、エラー発生のリスクが減少します。
- **可読性の向上**: コードのフローが明確になり、各モジュールの役割がより鮮明になります。

---

## 5. APIエンドポイントの改善 (`auto_strategy.py`)

### 現状の課題

`backend/app/api/auto_strategy.py` は、GA戦略生成に関するAPIエンドポイントを提供していますが、いくつかの点で改善の余地があります。

- **依存性注入の単純さ**: `get_auto_strategy_service` による依存性注入は機能していますが、より複雑な依存関係に対応するには力不足です。
- **レスポンスモデルの重複**: 複数のレスポンスモデルで `success: bool` や `message: str` といった共通フィールドが重複して定義されています。
- **エラーハンドリングの分散**: エラーハンドリングが各エンドポイントで個別に行われており、一貫性がありません。

### 提案

APIエンドポイントの保守性と拡張性を向上させるため、以下の改善を提案します。

1.  **DIコンテナの導入**:
    - `python-dependency-injector` のようなライブラリを導入し、`AutoStrategyService` やその他のサービスの依存関係をコンテナで管理します。これにより、依存関係の解決が自動化され、テストダブルの使用も容易になります。
2.  **レスポンスモデルの共通化**:
    - `success: bool` と `message: str` を持つベースレスポンスモデルを定義し、他のレスポンスモデルがそれを継承するようにします。これにより、コードの重複が削減され、APIレスポンスの一貫性が向上します。
3.  **エラーハンドリングの一元化**:
    - FastAPIの例外ハンドラ (`@app.exception_handler`) を使用して、カスタム例外（例: `ExperimentNotFound`）を定義し、アプリケーション全体でエラーレスポンスを一元管理します。これにより、エンドポイント内のロジックが簡素化されます。

**期待される効果:**

- **保守性の向上**: 依存関係の管理とエラーハンドリングが一元化され、コードの保守が容易になります。
- **テストの容易化**: DIコンテナにより、サービスのモック化が簡単になり、ユニットテストの作成が効率化されます。
- **コードのDRY原則**: レスポンスモデルの共通化により、コードの重複が排除されます。

---

## 6. 指標初期化ロジックの改善 (`indicator_initializer.py`)

### 現状の課題

`backend/app/core/services/auto_strategy/factories/indicator_initializer.py` は、指標の初期化を担当していますが、いくつかの責務が過剰であり、将来的な負債を抱えています。

- **フォールバックロジックの混在**: サポートされていない指標を代替指標にマッピングするロジックが `IndicatorInitializer` 内にハードコードされています。
- **レガシー名の存在**: 後方互換性のために、古い形式の指標名を生成・登録するロジックが残っています。
- **特定の指標への依存**: `STOCH` や `MACD` など、特定の指標の結果を特別扱いするロジックが含まれており、汎用性が低いです。

### 提案

`IndicatorInitializer` の責務を明確にし、よりクリーンで汎用的な実装を目指します。

1.  **フォールバックロジックの責務分離**:
    - 指標のフォールバックロジックを `indicator_registry` または専用の `FallbackService` に移譲します。これにより、`IndicatorInitializer` は純粋な初期化処理に集中できます。
2.  **レガシー名の非推奨化**:
    - `_get_legacy_indicator_name` メソッドと関連ロジックに `@deprecated` のようなマーカーを追加し、これらが技術的負債であることを明示します。将来的な削除計画を立て、コードベースをクリーンに保ちます。
3.  **指標結果ハンドリングの汎用化**:
    - `IndicatorConfig` に、指標のどの出力（例: `'macd'`）をデフォルトで使用するかを指定するフィールドを追加します。`IndicatorInitializer` はその設定を参照することで、特定の指標名に依存するハードコードされたロジックを排除します。

**期待される効果:**

- **責務の明確化**: `IndicatorInitializer` の責務が単一になり、コードの可読性と保守性が向上します。
- **技術的負債の管理**: レガシーコードが明確に識別され、計画的な削除が可能になります。
- **汎用性の向上**: 新しい指標を追加する際に、`IndicatorInitializer` を修正する必要がなくなり、拡張性が高まります。

---

## 7. GA設定管理の改善 (`ga_config.py`)

### 現状の課題

`backend/app/core/services/auto_strategy/models/ga_config.py` の `GAConfig` クラスは、多くの設定項目をフラットに管理しており、構造が不明確です。また、マジックナンバーの使用や、バリデーションの不足が見られます。

- **フラットな構造**: 関連する設定がグループ化されておらず、可読性が低いです。
- **マジックナンバー**: `from_dict` メソッド内でデフォルト値がハードコードされており、一元管理されていません。
- **限定的なバリデーション**: バリデーションが基本的な範囲チェックに留まっています。

### 提案

`GAConfig` の構造を改善し、保守性と堅牢性を高めます。

1.  **設定の構造化**:
    - 関連する設定項目をネストしたデータクラス（例: `EvolutionConfig`, `EvaluationConfig`）にまとめ、設定の階層構造を明確にします。
2.  **マジックナンバーの排除**:
    - デフォルト値をクラス属性として定数で定義し、`from_dict` や `__init__` から参照するように統一します。
3.  **バリデーションの強化**:
    - `pydantic` の `@validator` を活用し、より宣言的で強力なバリデーション（例: 許可されていない指標のチェック）を実装します。

**期待される効果:**

- **可読性の向上**: 設定の意図が明確になり、コードの理解が容易になります。
- **保守性の向上**: デフォルト値が一元管理され、変更が容易かつ安全になります。
- **堅牢性の向上**: より厳密なバリデーションにより、不正な設定によるエラーを未然に防ぎます。

---

## 8. GAエンジンの責務分離 (`ga_engine.py`)

### 現状の課題

`backend/app/core/services/auto_strategy/ga_engine.py` の `GAEngine` クラスは、GAの主要な処理を担当していますが、依存コンポーネントの直接的なインスタンス化や、複数の責務を単一メソッド内に抱えるなど、密結合な構造になっています。

- **依存関係のハードコード**: `RandomGeneGenerator` などのオペレータがコンストラクタ内で直接生成されており、テストが困難です。
- **冗長なロギング**: 設定全体をJSONとしてログ出力しており、可読性が低いです。
- **責務の集中**: `_generate_next_generation` メソッドが、選択、交叉、突然変異など多くの責務を担っています。

### 提案

`GAEngine` の責務を分離し、より疎結合でテストしやすい設計を目指します。

1.  **依存性の注入 (DI)**:
    - `GAEngine` のコンストラクタが、各種オペレータ（`SelectionOperator`, `CrossoverOperator` など）を引数として受け取るように変更します。これにより、外部で生成したインスタンスを注入でき、モック化が容易になります。
2.  **ロギングの改善**:
    - ログに出力する設定情報を、重要なパラメータに限定するか、`DEBUG` レベルでのみ詳細情報を出力するように変更します。
3.  **次世代生成ロジックの責務分離**:
    - `_generate_next_generation` のロジックを、`ReproductionOperator` のような新しいクラスに切り出します。このクラスが、選択、交叉、突然変異の各オペレータを内部で協調させる責務を担うようにします。

**期待される効果:**

- **テストの容易化**: 依存性が注入されることで、各コンポーネントを独立してテストできます。
- **可読性と保守性の向上**: 各クラスの責務が明確になり、コードの見通しが良くなります。
- **柔軟性の向上**: オペレータの実装を容易に差し替えられるようになり、アルゴリズムの実験がしやすくなります。

---

## 9. サービスレイヤーと状態管理の改善 (`auto_strategy_service.py`)

### 現状の課題

- **複雑なシングルトン**: スレッドセーフなシングルトンパターンが実装されていますが、FastAPIの依存性注入の仕組みを使えばよりシンプルに実現できます。
- **永続的でない状態管理**: 実験の進捗や結果がメモリ上に保存されているため、サーバープロセスが再起動すると失われ、複数ワーカーでの実行に対応できません。
- **DB接続管理**: データベース接続がインスタンス初期化時に一度だけ行われており、コネクションプールが有効に機能しない可能性があります。

### 提案

1.  **DIの活用**: シングルトン実装を廃止し、FastAPIの依存性注入（`Depends`）を使ってサービスのライフサイクルを管理します。
2.  **永続的な状態管理**: 実験の進捗や結果を、メモリではなくRedisやデータベースなどの永続ストアに保存するように変更します。
3.  **リクエスト毎のDB接続**: リクエスト毎にデータベース接続を取得・解放するよう、FastAPIの標準的なパターンに変更します。

**期待される効果**: スケーラビリティと堅牢性の向上、コードの簡素化。

---

## 10. 適応度評価の修正と改善 (`fitness_evaluator.py`)

### 現状の課題

- **重大な競合状態のリスク**: `_create_strategy_instance`メソッドが、`DynamicStrategy`クラスのクラス変数に遺伝子を設定しています。これにより、並列実行時に異なる評価スレッドが互いの戦略設定を上書きしてしまい、正しい評価ができません。
- **ハードコードされたペナルティ**: 適応度計算において、シャープレシオが低い場合や取引回数が少ない場合のペナルティがマジックナンバーとしてハードコードされています。
- **単純な適応度計算**: `TODO`コメントにもある通り、現在は単純な重み付き和で適応度を計算しており、より高度な正規化が求められます。

### 提案

1.  **スレッドセーフな戦略初期化**: `backtesting.py`ライブラリの`bt.run()`にパラメータを渡す機能を活用し、各バックテスト実行時に独立して戦略が初期化されるように修正します。クラス変数への代入を完全に排除します。
2.  **設定可能なペナルティ**: 適応度計算に用いるペナルティロジックを`GAConfig`に移動し、設定可能にします。
3.  **正規化手法の導入**: 各評価指標を0から1の範囲などに正規化してから重み付け計算を行うようにし、異なるスケールの指標を公平に扱えるようにします。

**期待される効果**: 評価の正確性と信頼性の確保、アルゴリズムの柔軟性向上。

---

## 11. 遺伝子生成ロジックの改善 (`random_gene_generator.py`)

### 現状の課題

- **複雑な設定処理**: `__init__`が辞書と`GAConfig`オブジェクトの両方を扱えるように作られており、冗長です。
- **ハードコードされたロジック**: 指標選択の重み、右オペランドの選択確率、リスク管理パラメータの範囲などがすべてハードコードされています。
- **巨大な条件分岐**: `_generate_threshold_value`内の指標をグループ化するロジックが巨大な`if/elif`ブロックになっており、メンテナンス性に乏しいです。

### 提案

1.  **`GAConfig`への統一**: `__init__`では常に`GAConfig`オブジェクトを受け取るようにし、型安全性を高めます。
2.  **設定の外部化**: ハードコードされている数値をすべて`GAConfig`に移動し、設定ファイルから一元管理できるようにします。
3.  **データ駆動へのリファクタリング**: `_generate_threshold_value`のロジックを、指標レジストリに`scale_type`のようなメタデータを追加し、それを参照する形にリファクタリングします。

**期待される効果**: コードの可読性と保守性の向上、遺伝子生成アルゴリズムの柔軟性向上。

---

## 12. 遺伝的オペレータの改善 (`crossover.py`, `mutation.py`)

### 現状の課題

- **不確実な交叉ロジック**: `_crossover_risk_management`の実装に、意図が不明確な部分やバグの可能性がある箇所が含まれています。
- **未実装の突然変異**: `_mutate_conditions`で、文字列ベースの右オペランド（指標名など）を突然変異させるロジックが未実装です。
- **ハードコードされた制約**: `_mutate_risk_management`で、突然変異後の値を丸める際の範囲がハードコードされています。

### 提案

1.  **交叉ロジックの明確化**: `_crossover_risk_management`のロジックを見直し、より意図が明確な方法（例: 親の値を単純に交換する、など）に修正します。
2.  **突然変異ロジックの実装**: 未実装の突然変異ロジックを、利用可能な指標リストを考慮して実装します。
3.  **制約の外部化**: 突然変異におけるパラメータのクランプ（範囲制約）を`GAConfig`で設定可能にします。

**期待される効果**: 遺伝的アルゴリズムの探査能力の向上、オペレータの信頼性と柔軟性の向上。

---

## 結論

本リファクタリング計画は、`auto_strategy` および `indicators` ディレクトリ内のコードの重複と複雑さを解消し、システムの全体的な健全性を向上させることを目指しています。提案された変更は、各モジュールの責務を明確にし、コードの一貫性を高め、将来的な機能拡張や保守を容易にするでしょう。

これらのリファクタリングは、一歩ずつ慎重に進める必要があります。特に、既存の機能への影響を最小限に抑えるため、単体テストと結合テストを徹底しながら実施することが重要です。TDD の原則に基づき、リファクタリングの各ステップでテストが確実にパスすることを確認します。

この計画が、より堅牢で保守しやすい取引戦略バックテストシステムの構築に貢献することを期待します。

---
