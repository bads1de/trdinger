## フロントエンド OHLCV データ取得・保存機能 設計計画書

### 1. はじめに

本計画書は、フロントエンドアプリケーションに Bybit 取引所から OHLCV データを取得し、データベースに保存する機能を実装するための詳細な設計を定義するものです。

### 2. UI コンポーネント設計

#### 2.1. OHLCV データ取得・保存ボタン

- **配置:** [`frontend/components/SymbolSelector.tsx`](frontend/components/SymbolSelector.tsx:1) の近傍、またはデータ管理を行う専用のセクションに配置します。
- **テキスト:**
  - 通常時: 「OHLCV データ取得・保存」
  - 実行中: 「取得・保存中...」
  - 完了時: 「取得・保存完了」
  - エラー時: 「エラーが発生しました」
- **インタラクション:**
  - クリックすると、選択されている取引ペアの OHLCV データ取得・保存処理を開始します。
  - 処理中はボタンを無効化し、スピナーなどのインジケーターを表示します。
  - 処理完了後、成功または失敗のメッセージをトースト通知などで表示します。

#### 2.2. ダークモード対応

- 既存の Tailwind CSS のダークモード設定 (`dark:` プレフィックス) を活用し、ライトモードとダークモードで適切な配色となるようにスタイリングします。
- ボタンの色、テキストの色、背景色などがテーマに応じて切り替わるようにします。

#### 2.3. ボタンの状態表示

- **実行中:** ボタン内にスピナーを表示し、テキストを「取得・保存中...」に変更します。ボタンは `disabled` 状態にします。
  - 例: `[スピナー] 取得・保存中...`
- **完了:** ボタンのテキストを「取得・保存完了」に変更し、一時的に成功を示すアイコン（例: チェックマーク）を表示します。その後、一定時間経過後に通常状態に戻すか、ユーザーのアクションがあるまで完了状態を維持します。
  - 例: `[✔] 取得・保存完了`
- **エラー:** ボタンのテキストを「エラーが発生しました」に変更し、エラーを示すアイコン（例: 警告マーク）を表示します。エラーメッセージの詳細はトースト通知で表示します。
  - 例: `[⚠] エラーが発生しました`

#### 2.4. 既存コンポーネントとの連携

- [`frontend/components/SymbolSelector.tsx`](frontend/components/SymbolSelector.tsx:1) で選択されている取引ペアをデータ取得の対象とします。
- 必要に応じて、`SymbolSelector` コンポーネントから選択中のシンボルを props として受け取る、または状態管理ライブラリ経由で共有します。

### 3. 機能設計

#### 3.1. 対象とする取引ペアの選定方法

- [`frontend/constants/index.ts`](frontend/constants/index.ts:1) に定義されている `SUPPORTED_TRADING_PAIRS` 配列から、ユーザーが [`frontend/components/SymbolSelector.tsx`](frontend/components/SymbolSelector.tsx:1) を通じて選択した取引ペアを対象とします。
- 初期状態では、`DEFAULT_TRADING_PAIR` を対象とするか、ユーザーに選択を促します。

#### 3.2. Bybit 取引所からのデータ取得ロジック

- **CCXT ライブラリの利用:** フロントエンドから直接 CCXT ライブラリを利用して Bybit API を呼び出すのではなく、バックエンド API 経由で CCXT を利用することを推奨します。これにより、API キーの管理やレートリミットの制御をサーバーサイドで行うことができます。
- **API エンドポイント (バックエンド側):**
  - 新規に `/api/data/collect-ohlcv` のようなエンドポイントをバックエンドに作成します。
  - このエンドポイントが内部で CCXT ライブラリを使用し、Bybit の `fetchOHLCV` メソッドを呼び出します。
- **リクエストパラメータ (フロントエンド → バックエンド):**
  - `symbol`: 取引ペアのシンボル (例: "BTC/USDT")
  - `timeframe`: 時間軸 (例: "1h")
  - `since`: 取得開始タイムスタンプ (オプション)
  - `limit`: 取得件数 (オプション、Bybit の API 制限を考慮)
- **リクエストパラメータ (バックエンド → Bybit):**
  - CCXT の `fetchOHLCV` の仕様に従います。

#### 3.3. データ保存戦略

- **バックエンド API 経由での保存:**
  - **理由:**
    - データの永続性と一元管理。
    - API キーなどの機密情報をフロントエンドに持たせないセキュリティ。
    - 重複データチェックなどのロジックをサーバーサイドで集中的に管理。
    - フロントエンドの負荷軽減。
  - **API 拡張/新規作成:**
    - 既存の [`frontend/app/api/data/candlesticks/route.ts`](frontend/app/api/data/candlesticks/route.ts:1) はデータ取得用のため、データ保存用の API エンドポイントを新規に作成します。
    - Next.js の Route Handlers を利用し、例えば [`frontend/app/api/data/ohlcv/route.ts`](frontend/app/api/data/ohlcv/route.ts) のようなパスで POST リクエストを受け付けるエンドポイントを作成します。
    - このエンドポイントは、内部でバックエンド（Python FastAPI など）のデータ保存 API を呼び出します。
  - **API インターフェース定義 (フロントエンド Next.js API → バックエンド FastAPI):**
    - **リクエスト (POST [`frontend/app/api/data/ohlcv/route.ts`](frontend/app/api/data/ohlcv/route.ts)):**
      ```json
      {
        "symbol": "BTC/USDT",
        "timeframe": "1h",
        "ohlcv_data": [
          {
            "timestamp": 1672531200000,
            "open": 16000,
            "high": 16100,
            "low": 15900,
            "close": 16050,
            "volume": 1000
          }
          // ... more data
        ]
      }
      ```
    - **レスポンス (バックエンド FastAPI → フロントエンド Next.js API):**
      ```json
      {
        "success": true,
        "message": "OHLCVデータの保存に成功しました。",
        "saved_count": 100, // 保存された件数
        "skipped_count": 10 // 重複によりスキップされた件数
      }
      ```
      またはエラー時:
      ```json
      {
        "success": false,
        "message": "OHLCVデータの保存に失敗しました。",
        "error": "データベースエラー詳細など"
      }
      ```

#### 3.4. 重複データ防止機能の具体的なアルゴリズム

- バックエンドのデータベース保存処理において、以下の条件で重複を判定します。
  - `symbol` (取引ペア)
  - `timeframe` (時間軸)
  - `timestamp` (ローソク足の開始時刻)
- データベースのテーブルに、これらの組み合わせに対してユニーク制約を設定することを推奨します。
- データ挿入時にユニーク制約違反が発生した場合は、そのデータをスキップし、重複としてカウントします。

#### 3.5. エラーハンドリング戦略

- **API エラー (Bybit):** バックエンド側で CCXT のエラーを捕捉し、適切なエラーコードとメッセージをフロントエンドに返却します。
- **ネットワークエラー:**
  - フロントエンドでの `fetch` 呼び出し時に `try...catch` でネットワークエラーを捕捉します。
  - バックエンド API 呼び出し時のネットワークエラーも同様に処理します。
- **データ処理エラー:**
  - データのバリデーションエラー（不正な形式など）は、各処理段階で検出し、エラーメッセージを表示します。
  - 保存処理中のデータベースエラーなどは、バックエンドからフロントエンドに通知します。
- **ユーザーフィードバック:** エラー発生時は、トースト通知や UI 上のメッセージエリアに、ユーザーフレンドリーなエラーメッセージを表示します。「不明なエラーが発生しました。時間をおいて再度お試しください。」のような汎用的なメッセージと、可能であれば具体的なエラー内容を併記します。

#### 3.6. ユーザーフィードバックの仕組み

- **トースト通知:**
  - 処理開始時: 「[シンボル] の OHLCV データ取得・保存を開始しました。」
  - 処理成功時: 「[シンボル] の OHLCV データ [件数] 件の取得・保存に成功しました。」
  - 処理失敗時: 「[シンボル] の OHLCV データ取得・保存に失敗しました。理由: [エラー理由]」
  - 部分成功時: 「[シンボル] の OHLCV データ [保存件数] 件を保存し、[スキップ件数] 件は重複のためスキップしました。」
- **UI 上のメッセージ表示:** ボタンの近傍や専用のステータス表示エリアに、処理の進捗や結果を簡潔に表示します。

#### 3.7. 非同期処理の管理方法

- **async/await:** API 呼び出しやデータ処理などの非同期処理は、`async/await` を使用して可読性の高いコードを記述します。
- **Promise チェーン:** 必要に応じて `Promise.all` や `Promise.race` などを活用します。
- **状態管理ライブラリとの連携:**
  - 処理のローディング状態、成功/失敗状態、取得したデータなどを状態管理ライブラリ（例: Zustand, Redux Toolkit, React Context API）で管理します。
  - これにより、UI コンポーネントは状態に応じてリアクティブに更新されます。
  - 例えば、`isLoading`, `error`, `successMessage` といった状態を管理します。

### 4. テスト戦略

#### 4.1. TDD アプローチの具体的な進め方

1.  **要件分析とテストケース作成:** 機能要件に基づいて、最初にテストケースを記述します（Jest を使用）。
2.  **テスト実行 (失敗):** 実装コードが存在しないため、テストは失敗します。
3.  **最小限の実装:** テストをパスするための最小限のコードを記述します。
4.  **テスト実行 (成功):** テストが成功することを確認します。
5.  **リファクタリング:** コードの品質を向上させるためにリファクタリングを行います。テストが引き続き成功することを確認します。
6.  上記サイクルを小さな単位で繰り返します。

#### 4.2. ユニットテスト、インテグレーションテストの対象範囲

- **ユニットテスト:**
  - UI コンポーネントのレンダリング、状態変化、イベントハンドラの動作（ボタンクリック、状態表示の切り替えなど）。
  - データ整形関数、バリデーション関数などの純粋関数。
  - 状態管理ストアのアクションとリデューサー（またはセレクター）。
- **インテグレーションテスト:**
  - フロントエンドの API クライアントと Next.js API ルートハンドラ間の連携。
    - Next.js API ルートハンドラがバックエンド API を正しく呼び出し、レスポンスを処理できるか。
  - UI コンポーネントと API 呼び出しの連携（ボタンクリック → API 呼び出し → UI 更新）。

#### 4.3. Bybit API 呼び出しを含むテストの作成方針

- **モック戦略:**
  - **フロントエンド:** Next.js API ルートハンドラを呼び出す `fetch` 関数をモックします (`jest.mock('node-fetch')` や `msw` などを使用)。これにより、実際のバックエンド API 呼び出しをせずに、API ルートハンドラのロジックをテストします。
  - **バックエンド (Python FastAPI 側):** CCXT ライブラリの `fetchOHLCV` メソッドをモックします (`unittest.mock.patch` などを使用)。これにより、実際の Bybit API を呼び出さずに、データ取得と保存ロジックをテストします。
- **実際の API コールを行う場合の注意点:**
  - 実際の API コールを含むテストは、頻繁に実行すると API レートリミットに抵触したり、コストが発生する可能性があるため、通常は CI 環境でのみ実行するか、手動実行に限定します。
  - テスト用のアカウントや API キーを使用し、本番環境のデータに影響を与えないようにします。
  - 取得するデータ量を最小限に抑えます。

#### 4.4. テストカバレッジ 80%達成のための具体的なテストケースの洗い出し

- **UI コンポーネント:**
  - ボタンが正しくレンダリングされるか。
  - ボタンクリック時に指定された関数が呼び出されるか。
  - ローディング状態が正しく表示されるか（スピナー、テキスト変更、disabled 属性）。
  - 完了状態が正しく表示されるか（テキスト変更、アイコン表示）。
  - エラー状態が正しく表示されるか（テキスト変更、アイコン表示）。
  - ダークモードでスタイルが正しく適用されるか。
- **API 連携 (フロントエンド):**
  - データ取得・保存 API が正しいパラメータで呼び出されるか。
  - API 成功時に UI が正しく更新され、成功メッセージが表示されるか。
  - API 失敗時に UI が正しく更新され、エラーメッセージが表示されるか。
  - ネットワークエラー発生時の処理。
- **データ処理ロジック:**
  - OHLCV データのバリデーション（必須フィールド、データ型）。
  - 重複データ判定ロジック（バックエンド側）。
- **状態管理:**
  - ローディング状態の開始と終了が正しく管理されるか。
  - エラー情報が正しく格納されるか。
  - 成功メッセージが正しく格納されるか。

### 5. 技術仕様の確認

#### 5.1. 既存の [`frontend/constants/index.ts`](frontend/constants/index.ts:1) の取引ペア定数の具体的な利用方法

- `SUPPORTED_TRADING_PAIRS` を [`frontend/components/SymbolSelector.tsx`](frontend/components/SymbolSelector.tsx:1) に渡し、ユーザーが選択できるようにします。
- データ取得・保存処理を実行する際に、選択された取引ペアの `symbol` プロパティを API リクエストに含めます。
- `categorizeTradingPairs` や `getTradingPairIcon` などのヘルパー関数は、UI 表示の際に活用できます。

#### 5.2. その他、考慮すべき既存のコードベースや技術スタック

- **Next.js:** API ルートハンドラ ([`frontend/app/api/*`](frontend/app/api/)) の作成、サーバーサイドレンダリング (SSR) やスタティックサイトジェネレーション (SSG) の特性を理解し、適切なデータフェッチ戦略を選択します。今回はクライアントサイドからのアクションが起点となるため、主にクライアントコンポーネントと API ルートの連携になります。
- **TypeScript:** 型定義を厳密に行い、コードの安全性を高めます。`TradingPair`, `CandlestickData` などの既存の型定義 ([`frontend/types/strategy.ts`](frontend/types/strategy.ts)) を活用し、必要に応じて新しい型を定義します。
- **Tailwind CSS:** UI コンポーネントのスタイリングには Tailwind CSS のユーティリティクラスを使用し、既存のデザイントークンやスタイルガイドラインに準拠します。ダークモード対応も Tailwind CSS の機能を利用します。
- **Jest:** ユニットテストおよびインテグレーションテストのフレームワークとして Jest を使用します。React Testing Library と組み合わせて UI コンポーネントのテストを行います。

### 6. 計画の承認と次のステップ

この設計計画書をご確認いただき、ご承認いただけましたら、次のステップとして、この計画書を Markdown ファイルとして保存し、開発フェーズに移行するために `code` モードへの切り替えを提案します。
