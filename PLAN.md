# トレーディング戦略バックテストサービス開発計画案 (フロントエンド: Next.js)

## 1. プロジェクトの目的と概要

本プロジェクトの目的は、私自身がテクニカル指標に基づいたトレーディング戦略を定義し、過去データを用いてその有効性を検証（バックテスト）できる Web サービスを開発することです。個人利用を想定し、まずは仮想通貨を対象としたシステム基盤を構築します。第一弾として、仮想通貨を対象とし、拡張性の高いシステム基盤を構築します。

## 2. システムアーキテクチャ

以下にシステム全体の構成図を示します。

```mermaid
graph TD
    A[ユーザー] --> B{Webフロントエンド (TypeScript - Next.js) & API Routes};
    B --> D[バックテストエンジン (Python)];
    B --> E[データベース (PostgreSQL/InfluxDBなど)];
    D --> E;
    F[外部データソース (取引所APIなど)] --> G[データ収集モジュール (Python)];
    G --> E;

    subgraph "ブラウザ"
        B
    end

    subgraph "サーバーサイド"
        D
        E
        G
    end
```

**各コンポーネントの説明:**

- **Web フロントエンド & API Routes (TypeScript - Next.js)**:
  - 役割: ユーザーインターフェースを提供し、API リクエストを処理します。戦略設定（設定ファイルのアップロード/編集）、バックテスト実行指示、結果（各種指標、グラフ）の表示を行います。API Routes として、バックテストエンジンやデータベースとの連携を行います。戦略設定の管理、バックテストジョブの管理、結果の取得と整形などを行います。
  - 技術: **Next.js** (React フレームワーク) のフロントエンド機能および API Routes 機能
- **バックテストエンジン (Python)**:
  - 役割: 中核となるロジック部分です。データベースから価格データを取得し、設定ファイルに基づいてテクニカル指標を計算、売買戦略を実行し、パフォーマンス（シャープレシオ、ドローダウン、勝率など）を評価します。Next.js API Routes から呼び出されることを想定します。
  - 技術候補: TA-Lib, Pandas, NumPy などのライブラリを活用。
- **データベース (TimescaleDB - Community Edition)**:
  - 役割: 仮想通貨の価格データ（分足）、戦略設定、バックテスト結果などを永続的に保存・管理します。
  - 技術候補: TimescaleDB (Community Edition) を使用します。
- **データ収集モジュール (Python)**:
  - 役割: 外部のデータソース（取引所 API など）から定期的に仮想通貨の価格データを取得し、整形してデータベースに格納します。
  - 技術候補: `requests`, `ccxt` などのライブラリを利用。

## 3. 主要機能

- **戦略定義**:
  - ユーザーは Web ユーザーインターフェースを用いて、使用するテクニカル指標、そのパラメータ、売買ルール（エントリー/エグジット条件）を定義します。定義された内容は内部的に管理されます。
  - 例:
    ```yaml
    strategy_name: "SMA_RSI_Cross"
    target_pair: "BTC/USD"
    timeframe: "1m" # 1分足
    indicators:
      - name: "SMA"
        params: { period: 20 }
      - name: "RSI"
        params: { period: 14 }
    entry_rules:
      - condition: "SMA(close, 20) > SMA(close, 50)" # 短期SMAが長期SMAを上回る (例)
      - condition: "RSI(close, 14) < 70"
    exit_rules:
      - condition: "SMA(close, 20) < SMA(close, 50)"
      - condition: "RSI(close, 14) > 30"
    ```
- **データ管理**:
  - 主要な仮想通貨ペアの分足データをデータベースで管理。
  - データ収集モジュールによる定期的なデータ更新。
- **バックテスト実行**:
  - ユーザーが定義した戦略と指定した期間でバックテストを実行。
  - 手数料やスリッページも考慮できるような拡張性を持たせます（MVP では簡易的でも可）。
- **結果表示**:
  - 主要な評価指標（総損益、勝率、プロフィットファクター、シャープレシオ、最大ドローダウンなど）を表示。
  - 損益曲線グラフ、取引履歴などを視覚的に表示。

## 4. MVP (Minimum Viable Product) の範囲

- **対象通貨ペア**: 1 つまたは数種類の主要な仮想通貨ペア（例: BTC/USD, ETH/USD）。
- **テクニカル指標**: 2〜3 種類の基本的なテクニカル指標（例: 移動平均線、RSI、MACD）をサポート。
- **戦略定義**: Web ユーザーインターフェース上で、複数の指標を組み合わせた単純な売買ルールを定義可能。
- **データ**: 過去 1 年程度の分足データをデータベースに用意。
- **バックテスト**: 指定した戦略と期間でバックテストを実行し、主要な評価指標（シャープレシオ、総損益、勝率）と簡単な損益グラフを Web 画面に表示。
- **UI**: 戦略設定 UI、バックテスト実行ボタン、結果表示画面を持つシンプルな Web アプリケーション (Next.js で構築)。

## 5. 開発ステップ（案）

1.  **フェーズ 1: バックテストエンジンのコア開発 (Python)**
    - 基本的なテクニカル指標計算ライブラリの選定・導入。
    - 設定ファイルに基づいた戦略実行ロジックの実装。
    - 主要な評価指標の計算ロジックの実装。
    - ライブラリ（例: ccxt）を用いて価格データを取得し、バックテストエンジンの単体テストを行う。
2.  **フェーズ 2: データ収集とデータベース構築**
    - データベース選定とスキーマ設計。
    - データ収集モジュールの開発（特定取引所の API から分足データを取得し DB に格納）。
    - 過去データの初期投入。
3.  **フェーズ 3: Web フロントエンドと API 開発 (MVP - Next.js)**
    - 戦略設定ユーザーインターフェースの実装（テクニカル指標や売買ルールの設定）。
    - バックテスト実行指示 UI。
    - MVP 範囲の結果表示画面（主要指標、簡易グラフ）。
    - バックテスト実行リクエストの受付、バックテストエンジン呼び出し、結果をフロントエンドに返す API Routes の実装。
4.  **フェーズ 4: 機能拡張と改善**
    - 対応テクニカル指標の追加。
    - より詳細な分析レポート機能（ドローダウン期間、取引詳細など）。
    - 戦略設定 UI の改善（GUI での設定など）。
    - 手数料・スリッページ考慮の精緻化。

## 6. 技術スタック候補（再掲）

- **Python**: バックテストエンジン、データ収集 (Pandas, NumPy, TA-Lib, ccxt)
- **TypeScript**: Web フロントエンド & API Routes (**Next.js**)
- **データベース**: TimescaleDB (Community Edition)
- **その他**: Docker (コンテナ化による環境構築の容易化)

## 7. 拡張性について

- **モジュール設計**: バックテストエンジン、指標計算、データアクセスなどを疎結合なモジュールとして設計し、機能追加や変更を容易にします。
- **設定ファイルの柔軟性**: 戦略定義ファイルを拡張しやすい形式（JSON/YAML）とし、新しい指標や複雑なロジックも将来的に表現できるようにします。
- **データベーススキーマ**: 将来的なデータ項目の追加にも対応しやすいように設計します。
- **プラグイン機構**: (将来構想) 新しいテクニカル指標や取引ロジックをプラグインとして追加できるような仕組みを検討できます。

## 8. LLM 統合の検討 (Gemini 想定)

- **目的**: ユーザーの戦略定義プロセスを簡素化し、より直感的なインターフェースを提供する。バックテスト結果の解釈を支援する。
- **想定されるユースケース**:
  - 自然言語での戦略定義入力から、戦略設定 UI への入力値や内部データ構造を生成・提案。
  - 既存の設定ファイルの内容解説やバリデーション。
  - バックテスト結果に関する質疑応答や分析サポート。
- **技術**: Google Gemini API
- **アーキテクチャ上の位置づけ**: Next.js API Routes を経由して Gemini API と連携する。ユーザーからの自然言語入力を API Routes が受け付け、Gemini に処理を依頼し、結果をフロントエンドに返す流れを想定。
- **開発ステップへの影響**:
  - フェーズ 3（Web フロントエンドと API 開発）において、LLM 連携用の UI と API Routes を追加開発する必要がある。
  - プロンプトエンジニアリングや API 連携ロジックの開発が必要になる。
