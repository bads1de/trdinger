# Auto Strategy 機能分析レポート

## 概要

現在のオートストラテジー機能（`auto_strategy` モジュール）のコードベースを分析し、構造的な制約、拡張性の限界、および最適化プロセスの課題を特定しました。
本システムは基本的な遺伝的アルゴリズム（GA）による戦略探索を実現していますが、より高度で実践的な戦略（マルチタイムフレーム、状態依存ロジックなど）を生成するためには根本的な構造改革が必要です。

## 1. 構造的な制約 (Structural Limitations)

### 1.1 単一タイムフレームの強制 (Single Timeframe Constraint) ✅ **実装済み**

> **実装完了日: 2024-12-09**
>
> - `IndicatorGene` に `timeframe: Optional[str]` フィールドを追加
> - `GAConfig` に MTF 設定（`enable_multi_timeframe`, `available_timeframes`, `mtf_indicator_probability`）を追加
> - `IndicatorGenerator` で MTF 指標生成対応
> - `MultiTimeframeDataProvider` クラスを新設（リサンプリング・キャッシュ機能）
> - `IndicatorCalculator` / `UniversalStrategy` で MTF データ使用対応
> - `GeneValidator` でタイムフレームバリデーション追加
> - `DictConverter` でシリアライズ/デシリアライズ対応

**旧現状:**

- ~~`StrategyGene` および `IndicatorGene` にタイムフレーム情報（例: "1h", "5m"）を保持するフィールドが存在しません。~~
- ~~戦略全体が、バックテスト実行時に指定された単一のタイムフレーム（`backtest_config["timeframe"]`）に依存して動作します。~~

**現在:**

- `IndicatorGene` に `timeframe` フィールドが追加され、各指標が異なるタイムフレームで計算可能
- 「日足でトレンドを確認し、1 時間足でエントリー」といった MTF 戦略を GA で探索可能

**~~影響~~:**

- ~~**マルチタイムフレーム（MTF）戦略が不可能**~~: 現在は対応済み

### 1.2 ステートレス・ロジック (Stateless Logic)

**現状:**

- 条件判定ロジック（`Condition`）は、現在のバーにおける指標値と閾値の単純比較（`A > B`）のみを表現します。
- 過去の状態やイベントの順序を記憶・参照する仕組みがありません。

**影響:**

- **シーケンス制御の欠如**: 「条件 A が発生した後、5 バー以内に条件 B が発生したらエントリー」といった順序性のあるロジックを表現できません。
- **状態管理の欠如**: 「直近 1 時間以内に取引していなければエントリー」といった状態依存のフィルタリングが不可能です。

### 1.3 階層構造の欠如 (Flat Structure)

**現状:**

- `ConditionGenerator` は単純な `Condition` オブジェクト、またはそれらをフラットに結合した `ConditionGroup` (OR 条件) を生成します。
- `ComplexConditionsStrategy` と名前が付いていますが、実態は単純な論理結合に留まっています。

**影響:**

- 複雑な論理ツリー（例: `(A AND B) OR (C AND (D OR E))`）のような高度な条件を柔軟に進化させることが困難です。現在の遺伝的演算子（交叉・変異）もこのフラットな構造を前提としています。

## 2. 評価・最適化プロセスの課題 (Optimization Issues)

### 2.1 フィットネス評価の統一不全

**現状:**

- `ga_engine.py` にて、単一目的最適化と多目的最適化の分岐処理（`if config.enable_multi_objective:`）が依然として残存しています。
- これによりコードの重複が生じ、保守性が低下しています。理論上は単一目的も「次元数 1 の多目的最適化」として統一的に扱うべきです。

### 2.2 ヒューリスティックな定数（Magic Numbers）の使用

**現状:**

- `individual_evaluator.py` にて、取引回数が 0 回の場合に `0.1` という固定値を返しています。
- 制約違反時に `0.0` を返しています。

**影響:**

- **進化の停滞**: 全く取引しない個体に（0 ではなく）正のスコアを与えることで、劣悪な個体が個体群に残留し、収束を遅らせる可能性があります。
- **ペナルティ関数の不備**: 制約違反を単一の値 `0.0` で処理すると、違反の「程度」が情報として失われ、GA が有効領域へ向かう勾配を得られません。

### 2.3 指標計算の前提

**現状:**

- シャープレシオなどの指標計算が、リターンの正規分布を前提とした標準的な計算式（`backtest_result` 内）に依存しています。
- 暗号資産市場のような非正規分布（Fat Tail）市場において、リスクを過小評価する可能性があります。

## 3. 設定と拡張性の課題 (Scalability & Configuration)

### 3.1 ハードコードされた制限

**現状:**

- `StrategyGene` クラス内で `MAX_INDICATORS = 5` がハードコードされています。
- `ConditionGenerator` 内で条件数を 3 つに制限するロジック（`random.sample(longs, 3)`）が存在します。

**影響:**

- 探索空間が人為的に狭められており、多数の指標を組み合わせることで初めて機能するような複雑なエッジ（優位性）を発見できない可能性があります。

### 3.2 パラメータ範囲の大域性

**現状:**

- パラメータの探索範囲（例: RSI の期間）が `GAConfig` でグローバルに定義されています。

**影響:**

- **粒度の粗い探索**: 「短期トレンド用の RSI（期間 5-15）」と「長期トレンド用の RSI（期間 50-100）」を区別して探索させることができず、効率的な最適化が困難です。

### 3.3 TPSL（利確・損切）の柔軟性不足

**現状:**

- `TPSLGene` は戦略全体で共有される単一のオブジェクトです。
- ロング・ショートで個別の TPSL 設定を持つことや、市場状況（ボラティリティなど）に応じて TPSL ロジックを動的に切り替える構造になっていません。

## 4. システムアーキテクチャ・運用上の潜在課題

### 4.1 エラーハンドリングとデバッグ情報の損失

**現状:**

- `parallel_evaluator.py` において、評価中に例外が発生した場合、一律でデフォルトのフィットネス値（`0.0`）が返されます。
- `logger.warning` でエラー内容は記録されますが、エラーの種類（タイムアウト、メモリ不足、論理エラー）による構造的な区別がありません。

**影響:**

- **デバッグの困難化**: 「なぜその個体が失敗したのか」を事後分析する際、単に「スコア 0」として扱われるため、システムの問題（バグ）なのか戦略の問題（タイムアウトなど）なのか判別が困難です。

### 4.2 フィットネス共有の計算量 ($O(N^2)$)

**現状:**

- `fitness_sharing.py` は、全個体間のペアワイズ距離を計算するナイーブな実装になっています。

**影響:**

- **スケーラビリティの欠如**: 個体数（Population Size）を数百〜数千に増やすと、バックテスト自体よりも類似度計算に時間がかかるようになり、大規模探索のボトルネックとなります。

### 4.3 設定の整合性チェック不足

**現状:**

- `GAConfig` のバリデーションは個別の値の範囲チェックが主です。
- `elite_size` が大きすぎて交叉・変異による多様性確保を阻害するケースなど、パラメータ間の相互作用による「実質的な設定ミス」を検出できません。

**影響:**

- ユーザーが不適切な設定（例：個体数 100 でエリート数 90 など）を行ってもエラーにならず、結果として「進化しない」という現象が発生し、UX を損ないます。

## 5. 詳細コンポーネント分析（TPSL / Position Sizing / Hybrid）

### 5.1 TPSL（利確・損切）の多様性欠如

**現状:**

- `TPSLService` は `Calculator` パターンで実装されていますが、多くのロジックでフォールバック（固定％）が発生しやすい構造です。
- 特に市場データ異常時や遺伝子未設定時に、戦略の意図とは無関係に `FixedPercentageCalculator` が適用され、GA が「何故か勝てない」理由を学習できないまま進行するリスクがあります。
- トレーリングストップや、時間経過による決済（Time-based Exit）のロジックが `TPSLGene` レベルで統合されていません。

### 5.2 ポジションサイジングのバックテスト統合不全

**現状:**

- `PositionSizingService` は高度なリスク計算（VaR など）を実装していますが、バックテストエンジン側での呼び出しコスト（計算時間）が考慮されていません。
- これを GA の評価ループ内で毎回フル実行すると、評価速度が極端に低下します。現状の GA 最適化では、ポジションサイジングの複雑性が逆に「評価の遅い個体」として淘汰圧になる可能性があります（タイムアウト等）。

### 5.3 Hybrid GA（ML 統合）のボトルネックとデータ汚染リスク

**現状:**

- `HybridIndividualEvaluator` では、バックテストごとに `_fetch_ohlcv_data` を行い、特徴量変換と推論を実行しています。
- **データ取得のオーバーヘッド**: 個体ごとに DB アクセスが発生する可能性があり、並列数が増えると DB がボトルネックになります。
- **データ汚染リスク**: `_fetch_ohlcv_data` が失敗した場合に空データを返すのではなく、警告のみで進むケースがあり、不完全なデータに基づく推論スコアがフィットネスに混入する可能性があります。

### 5.4 UniversalStrategy の責務過多と実装乖離 (CRITICAL)

**現状:**

- `UniversalStrategy.py` の `next()` メソッド内で、TP/SL 価格の計算が `TPSLService` ではなく単純な四則演算で実装されています（lines 212-226 付近）。
- これにより、`TPSLService` で実装されているはずの高度なリスク計算（ATR ベース、ボラティリティベース）が、実際のバックテスト実行時には**完全に無視**され、単純な固定％または直値のみで実行されています。
- `PositionSizingService` の呼び出しが `next()` 内で同期的に行われており、複雑なリスク計算を行うとバックテスト速度が極端に低下する構造になっています。

## 推奨される改善アクション（優先度順）

### Phase 1: クリティカルな修正 (Immediate)

1. **UniversalStrategy の修正**: `next()` メソッド内で `TPSLService` を正しく呼び出し、遺伝子で指定された計算ロジック（ATR 倍率など）が反映されるように変更する。
2. **UniversalStrategy の PositionSizing 修正**: 重厚な計算を毎ティック行うのではなく、エントリー時のみ、あるいはキャッシングを利用して計算負荷を下げる。

### Phase 2: 機能拡張 (High Impact)

3. ✅ **マルチタイムフレーム対応**: `IndicatorGene` に `timeframe` を追加し、バックテストエンジンを拡張。 **（実装完了: 2024-12-09）**
4. **ステートフル・ロジック**: `StateGene` クラスを新設し、過去の状態を参照可能にする。

### Phase 3: アーキテクチャ改善 (Medium Impact)

5. **データキャッシュ戦略**: 個体評価ループ外でのデータロードと共有参照（Read-Only）化。
6. **エラー情報の構造化**: `EvaluationResult` オブジェクトの導入。
7. **計算量削減**: フィットネス共有のアルゴリズム改善。
