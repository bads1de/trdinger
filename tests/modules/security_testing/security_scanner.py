"""
Comprehensive Security Scanner for automated vulnerability detection.
Extends SecurityTester with advanced scanning capabilities.
"""

import asyncio
import json
import logging
import os
import re
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum

try:
    from .security_tester import (
        SecurityViolationType,
        SecurityViolation,
    )
    from ...config.test_config import TestConfig, SecurityTestConfig
    from ...utils.test_utilities import TestLogger
except ImportError:
    # Fallback for direct execution
    import sys
    from pathlib import Path

    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from modules.security_testing.security_tester import (
        SecurityViolationType,
        SecurityViolation,
    )
    from config.test_config import TestConfig, SecurityTestConfig
    from utils.test_utilities import TestLogger


class VulnerabilityType(Enum):
    """Types of security vulnerabilities."""

    HARDCODED_CREDENTIALS = "hardcoded_credentials"
    WEAK_CRYPTOGRAPHY = "weak_cryptography"
    INSECURE_DEPENDENCIES = "insecure_dependencies"
    CODE_INJECTION = "code_injection"
    INFORMATION_DISCLOSURE = "information_disclosure"
    INSECURE_CONFIGURATION = "insecure_configuration"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_FAILURE = "authorization_failure"


@dataclass
class SecurityAlert:
    """Represents a security alert generated by the scanner."""

    alert_id: str
    vulnerability_type: VulnerabilityType
    severity: str  # "critical", "high", "medium", "low"
    title: str
    description: str
    affected_files: List[str]
    evidence: List[str]
    recommendations: List[str]
    cve_references: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    false_positive: bool = False


@dataclass
class VulnerabilityReport:
    """Comprehensive vulnerability assessment report."""

    scan_id: str
    scan_timestamp: datetime
    total_files_scanned: int
    vulnerabilities_found: int
    alerts_generated: List[SecurityAlert]
    scan_duration_seconds: float
    scan_coverage: Dict[str, int]
    risk_score: float
    recommendations_summary: List[str]


@dataclass
class LogAnalysisResult:
    """Result from comprehensive log file analysis."""

    log_files_analyzed: int
    security_events_detected: int
    suspicious_patterns_found: List[SecurityViolation]
    attack_indicators: List[Dict[str, Any]]
    log_integrity_issues: List[str]
    analysis_duration_seconds: float


class SecurityScanner:
    """
    Comprehensive security scanner for automated vulnerability detection.

    Requirements implemented:
    - 7.1: Log file scanning for sensitive information exposure
    - 7.4: Automated security vulnerability detection and alert generation
    """

    def __init__(self, config: TestConfig):
        self.config = config
        self.security_config: SecurityTestConfig = config.security_test_config
        self.logger = TestLogger("security_scanner", config.log_level)

        # Vulnerability detection patterns
        self.vulnerability_patterns = {
            VulnerabilityType.HARDCODED_CREDENTIALS: [
                r'password\s*=\s*["\'][^"\']{8,}["\']',
                r'secret\s*=\s*["\'][^"\']{16,}["\']',
                r'api_key\s*=\s*["\'][^"\']{20,}["\']',
                r'private_key\s*=\s*["\']-----BEGIN',
            ],
            VulnerabilityType.WEAK_CRYPTOGRAPHY: [
                r"MD5\s*\(",
                r"SHA1\s*\(",
                r"DES\s*\(",
                r"RC4\s*\(",
                r"ssl\.PROTOCOL_TLS",
            ],
            VulnerabilityType.CODE_INJECTION: [
                r"eval\s*\(",
                r"exec\s*\(",
                r"subprocess\.call\s*\([^)]*shell\s*=\s*True",
                r"os\.system\s*\(",
            ],
            VulnerabilityType.INFORMATION_DISCLOSURE: [
                r"print\s*\([^)]*password",
                r"console\.log\s*\([^)]*secret",
                r"logger\.[^(]*\([^)]*api_key",
            ],
        }

        # Suspicious log patterns
        self.suspicious_log_patterns = [
            r"failed\s+login\s+attempt",
            r"authentication\s+failed",
            r"unauthorized\s+access",
            r"sql\s+injection",
            r"xss\s+attempt",
            r"brute\s+force",
            r"directory\s+traversal",
        ]

        # Attack indicators
        self.attack_indicators = [
            r"union\s+select",  # SQL injection
            r"<script[^>]*>",  # XSS
            r"\.\.\/\.\.\/",  # Directory traversal
            r"cmd\.exe",  # Command injection
            r"/etc/passwd",  # File inclusion
        ]

    async def run_comprehensive_scan(self) -> VulnerabilityReport:
        """Run comprehensive security vulnerability scan."""
        scan_id = f"scan_{int(time.time())}"
        start_time = time.time()
        scan_timestamp = datetime.now()

        self.logger.info(f"Starting comprehensive security scan: {scan_id}")

        alerts = []
        total_files_scanned = 0
        scan_coverage = {}

        try:
            # 1. Source code vulnerability scanning
            self.logger.info("Scanning source code for vulnerabilities")
            code_alerts, code_files_scanned = (
                await self._scan_source_code_vulnerabilities()
            )
            alerts.extend(code_alerts)
            total_files_scanned += code_files_scanned
            scan_coverage["source_code"] = code_files_scanned

            # 2. Dependency vulnerability scanning
            self.logger.info("Scanning dependencies for known vulnerabilities")
            dep_alerts, dep_files_scanned = (
                await self._scan_dependency_vulnerabilities()
            )
            alerts.extend(dep_alerts)
            total_files_scanned += dep_files_scanned
            scan_coverage["dependencies"] = dep_files_scanned

            # 3. Configuration security scanning
            self.logger.info("Scanning configuration files for security issues")
            config_alerts, config_files_scanned = (
                await self._scan_configuration_security()
            )
            alerts.extend(config_alerts)
            total_files_scanned += config_files_scanned
            scan_coverage["configuration"] = config_files_scanned

            # 4. Log file security analysis
            self.logger.info("Analyzing log files for security events")
            log_alerts = await self._analyze_log_security()
            alerts.extend(log_alerts)

            # Calculate risk score
            risk_score = self._calculate_risk_score(alerts)

            # Generate recommendations
            recommendations = self._generate_security_recommendations(alerts)

            scan_duration = time.time() - start_time

            self.logger.info(f"Security scan completed: {len(alerts)} alerts generated")

            return VulnerabilityReport(
                scan_id=scan_id,
                scan_timestamp=scan_timestamp,
                total_files_scanned=total_files_scanned,
                vulnerabilities_found=len(alerts),
                alerts_generated=alerts,
                scan_duration_seconds=scan_duration,
                scan_coverage=scan_coverage,
                risk_score=risk_score,
                recommendations_summary=recommendations,
            )

        except Exception as e:
            self.logger.error(f"Security scan failed: {e}")
            raise

    async def _scan_source_code_vulnerabilities(
        self,
    ) -> Tuple[List[SecurityAlert], int]:
        """Scan source code for security vulnerabilities."""
        alerts = []
        files_scanned = 0

        source_paths = [
            Path("backend"),
            Path("frontend"),
            Path("tests"),
        ]

        for source_path in source_paths:
            if source_path.exists():
                async for file_path in self._get_source_files(source_path):
                    files_scanned += 1
                    file_alerts = await self._scan_file_for_vulnerabilities(file_path)
                    alerts.extend(file_alerts)

        return alerts, files_scanned

    async def _get_source_files(self, directory: Path):
        """Async generator for source files in directory."""
        file_extensions = [".py", ".js", ".ts", ".tsx", ".json", ".yaml", ".yml"]

        for file_path in directory.rglob("*"):
            if file_path.is_file() and file_path.suffix in file_extensions:
                # Skip node_modules and other irrelevant directories
                if any(
                    part in str(file_path)
                    for part in ["node_modules", ".git", "__pycache__"]
                ):
                    continue
                yield file_path

    async def _scan_file_for_vulnerabilities(
        self, file_path: Path
    ) -> List[SecurityAlert]:
        """Scan a single file for security vulnerabilities."""
        alerts = []

        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")

            for vuln_type, patterns in self.vulnerability_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(
                        pattern, content, re.IGNORECASE | re.MULTILINE
                    )
                    for match in matches:
                        alert = self._create_vulnerability_alert(
                            vuln_type, pattern, match, file_path, content
                        )
                        alerts.append(alert)

        except Exception as e:
            self.logger.warning(f"Could not scan file {file_path}: {e}")

        return alerts

    def _create_vulnerability_alert(
        self,
        vuln_type: VulnerabilityType,
        pattern: str,
        match: re.Match,
        file_path: Path,
        content: str,
    ) -> SecurityAlert:
        """Create a security alert from a vulnerability match."""
        # Extract context around the match
        start = max(0, match.start() - 100)
        end = min(len(content), match.end() + 100)
        context = content[start:end].replace("\n", "\\n")

        # Determine severity based on vulnerability type
        severity_map = {
            VulnerabilityType.HARDCODED_CREDENTIALS: "critical",
            VulnerabilityType.WEAK_CRYPTOGRAPHY: "high",
            VulnerabilityType.CODE_INJECTION: "critical",
            VulnerabilityType.INFORMATION_DISCLOSURE: "medium",
            VulnerabilityType.INSECURE_DEPENDENCIES: "high",
            VulnerabilityType.INSECURE_CONFIGURATION: "medium",
        }

        severity = severity_map.get(vuln_type, "medium")

        # Generate alert ID
        alert_id = (
            f"{vuln_type.value}_{hash(str(file_path) + pattern + str(match.start()))}"
        )

        return SecurityAlert(
            alert_id=alert_id,
            vulnerability_type=vuln_type,
            severity=severity,
            title=f"{vuln_type.value.replace('_', ' ').title()} Detected",
            description=f"Potential {vuln_type.value} found in {file_path.name}",
            affected_files=[str(file_path)],
            evidence=[f"Pattern: {pattern}", f"Context: {context}"],
            recommendations=self._get_vulnerability_recommendations(vuln_type),
        )

    def _get_vulnerability_recommendations(
        self, vuln_type: VulnerabilityType
    ) -> List[str]:
        """Get recommendations for fixing a specific vulnerability type."""
        recommendations_map = {
            VulnerabilityType.HARDCODED_CREDENTIALS: [
                "Remove hardcoded credentials from source code",
                "Use environment variables or secure vaults for sensitive data",
                "Implement proper secrets management",
            ],
            VulnerabilityType.WEAK_CRYPTOGRAPHY: [
                "Upgrade to strong cryptographic algorithms",
                "Use AES-256 for symmetric encryption",
                "Use RSA-2048+ or ECDSA for asymmetric encryption",
            ],
            VulnerabilityType.CODE_INJECTION: [
                "Validate and sanitize all user inputs",
                "Use parameterized queries for database operations",
                "Avoid dynamic code execution",
            ],
            VulnerabilityType.INFORMATION_DISCLOSURE: [
                "Remove sensitive information from logs",
                "Implement proper logging practices",
                "Use structured logging with appropriate levels",
            ],
        }

        return recommendations_map.get(
            vuln_type, ["Review and fix the identified issue"]
        )

    async def _scan_dependency_vulnerabilities(self) -> Tuple[List[SecurityAlert], int]:
        """Scan dependencies for known vulnerabilities."""
        alerts = []
        files_scanned = 0

        # Scan Python dependencies
        requirements_files = [
            Path("backend/requirements.txt"),
            Path("requirements.txt"),
        ]

        for req_file in requirements_files:
            if req_file.exists():
                files_scanned += 1
                dep_alerts = await self._scan_python_dependencies(req_file)
                alerts.extend(dep_alerts)

        # Scan Node.js dependencies
        package_files = [
            Path("frontend/package.json"),
            Path("package.json"),
        ]

        for pkg_file in package_files:
            if pkg_file.exists():
                files_scanned += 1
                dep_alerts = await self._scan_nodejs_dependencies(pkg_file)
                alerts.extend(dep_alerts)

        return alerts, files_scanned

    async def _scan_python_dependencies(
        self, requirements_file: Path
    ) -> List[SecurityAlert]:
        """Scan Python dependencies for vulnerabilities."""
        alerts = []

        try:
            # This is a mock implementation - in real scenario, this would use tools like safety or pip-audit
            content = requirements_file.read_text()

            # Known vulnerable packages (example)
            vulnerable_packages = {
                "django": ["<3.2.0", "Security vulnerability in older versions"],
                "requests": ["<2.25.0", "SSL verification bypass vulnerability"],
                "pyyaml": ["<5.4.0", "Arbitrary code execution vulnerability"],
            }

            for line in content.split("\n"):
                line = line.strip()
                if line and not line.startswith("#"):
                    package_name = (
                        line.split("==")[0].split(">=")[0].split("<=")[0].strip()
                    )

                    if package_name.lower() in vulnerable_packages:
                        vuln_info = vulnerable_packages[package_name.lower()]
                        alert = SecurityAlert(
                            alert_id=f"dep_vuln_{package_name}_{hash(line)}",
                            vulnerability_type=VulnerabilityType.INSECURE_DEPENDENCIES,
                            severity="high",
                            title=f"Vulnerable Dependency: {package_name}",
                            description=vuln_info[1],
                            affected_files=[str(requirements_file)],
                            evidence=[
                                f"Package: {line}",
                                f"Vulnerable version: {vuln_info[0]}",
                            ],
                            recommendations=[
                                f"Update {package_name} to latest secure version",
                                "Review security advisories for the package",
                                "Consider alternative packages if updates are not available",
                            ],
                        )
                        alerts.append(alert)

        except Exception as e:
            self.logger.warning(
                f"Could not scan Python dependencies in {requirements_file}: {e}"
            )

        return alerts

    async def _scan_nodejs_dependencies(
        self, package_file: Path
    ) -> List[SecurityAlert]:
        """Scan Node.js dependencies for vulnerabilities."""
        alerts = []

        try:
            # This is a mock implementation - in real scenario, this would use npm audit or similar
            content = package_file.read_text()
            package_data = json.loads(content)

            dependencies = package_data.get("dependencies", {})
            dev_dependencies = package_data.get("devDependencies", {})
            all_deps = {**dependencies, **dev_dependencies}

            # Known vulnerable packages (example)
            vulnerable_packages = {
                "lodash": ["<4.17.21", "Prototype pollution vulnerability"],
                "axios": ["<0.21.1", "Server-side request forgery vulnerability"],
                "express": ["<4.17.1", "Various security vulnerabilities"],
            }

            for package_name, version in all_deps.items():
                if package_name.lower() in vulnerable_packages:
                    vuln_info = vulnerable_packages[package_name.lower()]
                    alert = SecurityAlert(
                        alert_id=f"dep_vuln_{package_name}_{hash(version)}",
                        vulnerability_type=VulnerabilityType.INSECURE_DEPENDENCIES,
                        severity="high",
                        title=f"Vulnerable Dependency: {package_name}",
                        description=vuln_info[1],
                        affected_files=[str(package_file)],
                        evidence=[
                            f"Package: {package_name}@{version}",
                            f"Vulnerable version: {vuln_info[0]}",
                        ],
                        recommendations=[
                            f"Update {package_name} to latest secure version",
                            "Run npm audit to check for vulnerabilities",
                            "Consider using npm audit fix to automatically fix issues",
                        ],
                    )
                    alerts.append(alert)

        except Exception as e:
            self.logger.warning(
                f"Could not scan Node.js dependencies in {package_file}: {e}"
            )

        return alerts

    async def _scan_configuration_security(self) -> Tuple[List[SecurityAlert], int]:
        """Scan configuration files for security issues."""
        alerts = []
        files_scanned = 0

        config_files = [
            Path(".env"),
            Path("backend/.env"),
            Path("frontend/.env"),
            Path("docker-compose.yml"),
            Path("nginx.conf"),
        ]

        for config_file in config_files:
            if config_file.exists():
                files_scanned += 1
                config_alerts = await self._scan_config_file(config_file)
                alerts.extend(config_alerts)

        return alerts, files_scanned

    async def _scan_config_file(self, config_file: Path) -> List[SecurityAlert]:
        """Scan a configuration file for security issues."""
        alerts = []

        try:
            content = config_file.read_text()

            # Check for insecure configurations
            insecure_patterns = [
                (r"DEBUG\s*=\s*True", "Debug mode enabled in production"),
                (r"ALLOWED_HOSTS\s*=\s*\[\s*\*\s*\]", "Wildcard allowed hosts"),
                (r"SSL_VERIFY\s*=\s*False", "SSL verification disabled"),
                (r'password\s*=\s*["\']admin["\']', "Default admin password"),
            ]

            for pattern, description in insecure_patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    alert = SecurityAlert(
                        alert_id=f"config_vuln_{hash(str(config_file) + pattern)}",
                        vulnerability_type=VulnerabilityType.INSECURE_CONFIGURATION,
                        severity="medium",
                        title="Insecure Configuration Detected",
                        description=description,
                        affected_files=[str(config_file)],
                        evidence=[f"Pattern: {pattern}", f"Match: {match.group()}"],
                        recommendations=[
                            "Review and secure configuration settings",
                            "Use environment-specific configurations",
                            "Follow security best practices for configuration",
                        ],
                    )
                    alerts.append(alert)

        except Exception as e:
            self.logger.warning(f"Could not scan config file {config_file}: {e}")

        return alerts

    async def _analyze_log_security(self) -> List[SecurityAlert]:
        """Analyze log files for security events and indicators."""
        alerts = []

        log_paths = self.security_config.log_scan_paths or [
            "backend/logs",
            "frontend/logs",
            "tests/logs",
            "/var/log",
        ]

        for log_path_str in log_paths:
            log_path = Path(log_path_str)
            if log_path.exists():
                if log_path.is_file():
                    log_alerts = await self._analyze_log_file(log_path)
                    alerts.extend(log_alerts)
                elif log_path.is_dir():
                    for log_file in log_path.rglob("*.log"):
                        log_alerts = await self._analyze_log_file(log_file)
                        alerts.extend(log_alerts)

        return alerts

    async def _analyze_log_file(self, log_file: Path) -> List[SecurityAlert]:
        """Analyze a single log file for security events."""
        alerts = []

        try:
            content = log_file.read_text(encoding="utf-8", errors="ignore")

            # Check for suspicious patterns
            for pattern in self.suspicious_log_patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    alert = SecurityAlert(
                        alert_id=f"log_security_{hash(str(log_file) + pattern + str(match.start()))}",
                        vulnerability_type=VulnerabilityType.INFORMATION_DISCLOSURE,
                        severity="medium",
                        title="Suspicious Activity Detected in Logs",
                        description=f"Suspicious pattern found: {pattern}",
                        affected_files=[str(log_file)],
                        evidence=[f"Pattern: {pattern}", f"Context: {match.group()}"],
                        recommendations=[
                            "Investigate the suspicious activity",
                            "Review access logs and authentication events",
                            "Consider implementing additional monitoring",
                        ],
                    )
                    alerts.append(alert)

            # Check for attack indicators
            for pattern in self.attack_indicators:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    alert = SecurityAlert(
                        alert_id=f"attack_indicator_{hash(str(log_file) + pattern + str(match.start()))}",
                        vulnerability_type=VulnerabilityType.CODE_INJECTION,
                        severity="high",
                        title="Potential Attack Detected",
                        description=f"Attack indicator found: {pattern}",
                        affected_files=[str(log_file)],
                        evidence=[f"Pattern: {pattern}", f"Context: {match.group()}"],
                        recommendations=[
                            "Immediate investigation required",
                            "Check for successful attacks",
                            "Review and strengthen input validation",
                        ],
                    )
                    alerts.append(alert)

        except Exception as e:
            self.logger.warning(f"Could not analyze log file {log_file}: {e}")

        return alerts

    def _calculate_risk_score(self, alerts: List[SecurityAlert]) -> float:
        """Calculate overall risk score based on alerts."""
        if not alerts:
            return 0.0

        severity_weights = {
            "critical": 10.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 1.0,
        }

        total_score = sum(severity_weights.get(alert.severity, 1.0) for alert in alerts)
        max_possible_score = len(alerts) * 10.0

        return (
            min(total_score / max_possible_score * 100, 100.0)
            if max_possible_score > 0
            else 0.0
        )

    def _generate_security_recommendations(
        self, alerts: List[SecurityAlert]
    ) -> List[str]:
        """Generate high-level security recommendations based on alerts."""
        recommendations = set()

        vuln_types = {alert.vulnerability_type for alert in alerts}

        if VulnerabilityType.HARDCODED_CREDENTIALS in vuln_types:
            recommendations.add("Implement proper secrets management system")
            recommendations.add("Use environment variables for sensitive configuration")

        if VulnerabilityType.WEAK_CRYPTOGRAPHY in vuln_types:
            recommendations.add("Upgrade cryptographic algorithms to current standards")
            recommendations.add("Review and update encryption implementations")

        if VulnerabilityType.INSECURE_DEPENDENCIES in vuln_types:
            recommendations.add("Establish regular dependency update process")
            recommendations.add("Implement automated vulnerability scanning in CI/CD")

        if VulnerabilityType.CODE_INJECTION in vuln_types:
            recommendations.add("Implement comprehensive input validation")
            recommendations.add("Use parameterized queries and prepared statements")

        if VulnerabilityType.INFORMATION_DISCLOSURE in vuln_types:
            recommendations.add("Review and secure logging practices")
            recommendations.add("Implement log sanitization for sensitive data")

        return list(recommendations)

    async def generate_security_alerts(
        self, alerts: List[SecurityAlert]
    ) -> Dict[str, Any]:
        """Generate security alerts for violations."""
        alert_summary = {
            "total_alerts": len(alerts),
            "critical_alerts": len([a for a in alerts if a.severity == "critical"]),
            "high_alerts": len([a for a in alerts if a.severity == "high"]),
            "medium_alerts": len([a for a in alerts if a.severity == "medium"]),
            "low_alerts": len([a for a in alerts if a.severity == "low"]),
            "alerts_by_type": {},
            "immediate_action_required": [],
        }

        # Group alerts by type
        for alert in alerts:
            vuln_type = alert.vulnerability_type.value
            if vuln_type not in alert_summary["alerts_by_type"]:
                alert_summary["alerts_by_type"][vuln_type] = 0
            alert_summary["alerts_by_type"][vuln_type] += 1

            # Mark critical and high severity alerts for immediate action
            if alert.severity in ["critical", "high"]:
                alert_summary["immediate_action_required"].append(
                    {
                        "alert_id": alert.alert_id,
                        "title": alert.title,
                        "severity": alert.severity,
                        "affected_files": alert.affected_files,
                    }
                )

        # Log alerts
        if alert_summary["critical_alerts"] > 0:
            self.logger.critical(
                f"CRITICAL SECURITY ALERTS: {alert_summary['critical_alerts']} found"
            )

        if alert_summary["high_alerts"] > 0:
            self.logger.error(
                f"HIGH SECURITY ALERTS: {alert_summary['high_alerts']} found"
            )

        self.logger.info(
            f"Security scan completed: {len(alerts)} total alerts generated"
        )

        return alert_summary
