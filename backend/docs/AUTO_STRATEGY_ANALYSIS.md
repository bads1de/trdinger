# Auto Strategy 機能分析レポート

## 概要

現在のオートストラテジー機能（`auto_strategy` モジュール）のコードベースを分析し、構造的な制約、拡張性の限界、および最適化プロセスの課題を特定しました。
本システムは基本的な遺伝的アルゴリズム（GA）による戦略探索を実現していますが、より高度で実践的な戦略（マルチタイムフレーム、状態依存ロジックなど）を生成するためには根本的な構造改革が必要です。

## 1. 構造的な制約 (Structural Limitations)

### 1.1 単一タイムフレームの強制 (Single Timeframe Constraint) ✅ **実装済み**

> **実装完了日: 2024-12-09**
>
> - `IndicatorGene` に `timeframe: Optional[str]` フィールドを追加
> - `GAConfig` に MTF 設定（`enable_multi_timeframe`, `available_timeframes`, `mtf_indicator_probability`）を追加
> - `IndicatorGenerator` で MTF 指標生成対応
> - `MultiTimeframeDataProvider` クラスを新設（リサンプリング・キャッシュ機能）
> - `IndicatorCalculator` / `UniversalStrategy` で MTF データ使用対応
> - `GeneValidator` でタイムフレームバリデーション追加
> - `DictConverter` でシリアライズ/デシリアライズ対応

**旧現状:**

- ~~`StrategyGene` および `IndicatorGene` にタイムフレーム情報（例: "1h", "5m"）を保持するフィールドが存在しません。~~
- ~~戦略全体が、バックテスト実行時に指定された単一のタイムフレーム（`backtest_config["timeframe"]`）に依存して動作します。~~

**現在:**

- `IndicatorGene` に `timeframe` フィールドが追加され、各指標が異なるタイムフレームで計算可能
- 「日足でトレンドを確認し、1 時間足でエントリー」といった MTF 戦略を GA で探索可能

**~~影響~~:**

- ~~**マルチタイムフレーム（MTF）戦略が不可能**~~: 現在は対応済み

### 1.2 ステートレス・ロジック (Stateless Logic) ✅ **実装済み**

> **実装完了日: 2025-12-09**
>
> - `StatefulCondition` モデルを新設（トリガー条件 + フォロー条件 + lookback_bars + cooldown_bars）
> - `StateTracker` クラスを新設（イベント記録・判定機能）
> - `ConditionEvaluator` に `evaluate_stateful_condition` / `check_and_record_trigger` メソッドを追加
> - `StrategyGene` に `stateful_conditions: List[StatefulCondition]` フィールドを追加
> - `UniversalStrategy` に `StateTracker` を統合し、`next()` で自動的にトリガー記録・評価
> - `DictConverter` でシリアライズ/デシリアライズに対応
> - TDD によるテストセットを追加完了

**旧現状:**

- ~~条件判定ロジック（`Condition`）は、現在のバーにおける指標値と閾値の単純比較（`A > B`）のみを表現します。~~
- ~~過去の状態やイベントの順序を記憶・参照する仕組みがありません。~~

**現在:**

- `StatefulCondition` により「条件 A が発生してから N バー以内に条件 B」といったシーケンス制御が可能
- `StateTracker` がバックテスト中のイベント履歴を追跡

**~~影響~~:**

- ~~**シーケンス制御の欠如**: 現在は `StatefulCondition` で対応済み~~
- ~~**状態管理の欠如**: 現在は `StateTracker` で対応済み~~

### 1.3 階層構造の欠如 (Flat Structure) ✅ **実装済み**

> **実装完了日: 2025-12-09**
>
> - `ConditionGroup` に `operator` (AND/OR) を追加し、再帰構造（ネスティング）をサポート
> - `ConditionEvaluator` で再帰的な評価ロジックを実装
> - `ComplexConditionsStrategy` で確率的に階層構造（グループ化）を生成するロジックを追加
> - `DictConverter` で再帰的なシリアライズ/デシリアライズに対応 (TDD)
> - `GeneValidator` および `GeneticOperators` (交叉・変異) を再帰構造に対応・修正完了 (Double Check)
> - TDD によるテストセット（モデル、評価、生成、シリアライズ、検証、変異）を追加完了

**旧現状:**

- ~~`ConditionGenerator` は単純な `Condition` オブジェクト、またはそれらをフラットに結合した `ConditionGroup` (OR 条件) を生成します。~~
- ~~`ComplexConditionsStrategy` と名前が付いていますが、実態は単純な論理結合に留まっています。~~

**現在:**

- `ConditionGroup` が `(A AND B) OR (C AND D)` のような任意の深さの論理ツリーを表現可能
- 生成戦略が確率的に条件をグループ化し、複雑なロジックを進化の過程で生成可能
- バリデーションと遺伝的演算子が階層構造を安全に処理・維持可能

**~~影響~~:**

- ~~**複雑な論理ツリーが困難**: 現在は構造的に対応済み~~

## 2. 評価・最適化プロセスの課題 (Optimization Issues)

### 2.1 フィットネス評価の統一不全 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `EvolutionRunner.run_evolution` メソッドにロジックを統合（単一・多目的共通化）
> - `ga_engine.py` の条件分岐を削除
> - HallOfFame / ParetoFront のポリモーフィックな扱いを実装

**旧現状:**

- ~~`ga_engine.py` にて、単一目的最適化と多目的最適化の分岐処理（`if config.enable_multi_objective:`）が依然として残存しています。~~
- ~~これによりコードの重複が生じ、保守性が低下しています。理論上は単一目的も「次元数 1 の多目的最適化」として統一的に扱うべきです。~~

### 2.2 ヒューリスティックな定数（Magic Numbers）の使用 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `GAConfig` に `zero_trades_penalty` と `constraint_violation_penalty` パラメータを追加
> - `individual_evaluator.py` でこれらの設定値を参照するように変更
> - フロントエンドからも設定可能

**旧現状:**

- ~~`individual_evaluator.py` にて、取引回数が 0 回の場合に `0.1` という固定値を返しています。~~
- ~~制約違反時に `0.0` を返しています。~~

**~~影響~~:**

- ~~**進化の停滞**: 全く取引しない個体に（0 ではなく）正のスコアを与えることで、劣悪な個体が個体群に残留し、収束を遅らせる可能性があります。~~
- ~~**ペナルティ関数の不備**: 制約違反を単一の値 `0.0` で処理すると、違反の「程度」が情報として失われ、GA が有効領域へ向かう勾配を得られません。~~

### 2.3 指標計算の前提

**現状:**

- シャープレシオなどの指標計算が、リターンの正規分布を前提とした標準的な計算式（`backtest_result` 内）に依存しています。
- 暗号資産市場のような非正規分布（Fat Tail）市場において、リスクを過小評価する可能性があります。

## 3. 設定と拡張性の課題 (Scalability & Configuration)

### 3.1 ハードコードされた制限 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `StrategyGene.MAX_INDICATORS` を `GAConfig.max_indicators` に移行
> - `ConditionGenerator` の条件数制限を `GAConfig` から取得するように変更
> - これらの値をフロントエンドから設定可能

**旧現状:**

- ~~`StrategyGene` クラス内で `MAX_INDICATORS = 5` がハードコードされています。~~
- ~~`ConditionGenerator` 内で条件数を 3 つに制限するロジック（`random.sample(longs, 3)`）が存在します。~~

**~~影響~~:**

- ~~探索空間が人為的に狭められており、多数の指標を組み合わせることで初めて機能するような複雑なエッジ（優位性）を発見できない可能性があります。~~

### 3.2 パラメータ範囲の大域性

**現状:**

- パラメータの探索範囲（例: RSI の期間）が `GAConfig` でグローバルに定義されています。

**影響:**

- **粒度の粗い探索**: 「短期トレンド用の RSI（期間 5-15）」と「長期トレンド用の RSI（期間 50-100）」を区別して探索させることができず、効率的な最適化が困難です。

### 3.3 TPSL（利確・損切）の柔軟性不足

**現状:**

- `TPSLGene` は戦略全体で共有される単一のオブジェクトです。
- ロング・ショートで個別の TPSL 設定を持つことや、市場状況（ボラティリティなど）に応じて TPSL ロジックを動的に切り替える構造になっていません。

## 4. システムアーキテクチャ・運用上の潜在課題

### 4.1 エラーハンドリングとデバッグ情報の損失 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `ParallelEvaluator` にエラー種別の詳細分類機能（`_categorize_error`）を追加
> - エラーカテゴリ: `timeout`, `memory`, `data_error`, `logic_error`, `other`
> - 最近のエラー履歴（最大 20 件）を保持し、デバッグ情報として取得可能
> - `get_statistics()` でエラー種別と履歴を含む詳細な統計情報を返却

**旧現状:**

- ~~`parallel_evaluator.py` において、評価中に例外が発生した場合、一律でデフォルトのフィットネス値（`0.0`）が返されます。~~
- ~~`logger.warning` でエラー内容は記録されますが、エラーの種類（タイムアウト、メモリ不足、論理エラー）による構造的な区別がありません。~~

**~~影響~~:**

- ~~**デバッグの困難化**: 「なぜその個体が失敗したのか」を事後分析する際、単に「スコア 0」として扱われるため、システムの問題（バグ）なのか戦略の問題（タイムアウトなど）なのか判別が困難です。~~

### 4.2 フィットネス共有の計算量 ($O(N^2)$) ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - KD-Tree (`scipy.spatial.cKDTree`) を使用した空間分割による近傍探索で $O(N \log N)$ に改善
> - 大規模集団向けのサンプリングベース近似を実装
> - `compute_niche_counts_vectorized` / `find_neighbors_kdtree` メソッドを追加

**旧現状:**

- ~~`fitness_sharing.py` は、全個体間のペアワイズ距離を計算するナイーブな実装になっています。~~

**~~影響~~:**

- ~~**スケーラビリティの欠如**: 個体数（Population Size）を数百〜数千に増やすと、バックテスト自体よりも類似度計算に時間がかかるようになり、大規模探索のボトルネックとなります。~~

### 4.3 設定の整合性チェック不足 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `GASettings` にパラメータ間の整合性チェック（`elite_size` < `population_size` など）を追加
> - 不適切な設定の場合はバリデーションエラーを返す

**旧現状:**

- ~~`GAConfig` のバリデーションは個別の値の範囲チェックが主です。~~
- ~~`elite_size` が大きすぎて交叉・変異による多様性確保を阻害するケースなど、パラメータ間の相互作用による「実質的な設定ミス」を検出できません。~~

**~~影響~~:**

- ~~ユーザーが不適切な設定（例：個体数 100 でエリート数 90 など）を行ってもエラーにならず、結果として「進化しない」という現象が発生し、UX を損ないます。~~

## 5. 詳細コンポーネント分析（TPSL / Position Sizing / Hybrid）

### 5.1 TPSL（利確・損切）の多様性欠如

**現状:**

- `TPSLService` は `Calculator` パターンで実装されていますが、多くのロジックでフォールバック（固定％）が発生しやすい構造です。
- 特に市場データ異常時や遺伝子未設定時に、戦略の意図とは無関係に `FixedPercentageCalculator` が適用され、GA が「何故か勝てない」理由を学習できないまま進行するリスクがあります。
- トレーリングストップや、時間経過による決済（Time-based Exit）のロジックが `TPSLGene` レベルで統合されていません。

### 5.2 ポジションサイジングのバックテスト統合不全 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `PositionSizingService.calculate_position_size_fast()` メソッドを実装
> - VaR、Expected Shortfall 等の重い計算をスキップし、純粋なポジションサイズのみを高速計算
> - `UniversalStrategy._calculate_position_size()` がこの高速メソッドを呼び出すように統合済み
> - 市場データ取得やバリデーションも簡易化し、バックテストループ内での高速実行を実現

**旧現状:**

- ~~`PositionSizingService` は高度なリスク計算（VaR など）を実装していますが、バックテストエンジン側での呼び出しコスト（計算時間）が考慮されていません。~~
- ~~これを GA の評価ループ内で毎回フル実行すると、評価速度が極端に低下します。現状の GA 最適化では、ポジションサイジングの複雑性が逆に「評価の遅い個体」として淘汰圧になる可能性があります（タイムアウト等）。~~

### 5.3 Hybrid GA（ML 統合）のボトルネックとデータ汚染リスク ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `HybridIndividualEvaluator._fetch_ohlcv_data` を親クラスの `_data_cache`（LRUCache）を活用するように修正
> - 同一の銘柄・時間足・期間のデータはキャッシュから取得し、DB アクセスを最小化
> - データ取得失敗時は `None` を返し、ML 予測をスキップ（ベースフィットネスのみを使用）
> - 必須パラメータのチェックを追加し、不完全なリクエストを早期に検出

**旧現状:**

- ~~`HybridIndividualEvaluator` では、バックテストごとに `_fetch_ohlcv_data` を行い、特徴量変換と推論を実行しています。~~
- ~~**データ取得のオーバーヘッド**: 個体ごとに DB アクセスが発生する可能性があり、並列数が増えると DB がボトルネックになります。~~
- ~~**データ汚染リスク**: `_fetch_ohlcv_data` が失敗した場合に空データを返すのではなく、警告のみで進むケースがあり、不完全なデータに基づく推論スコアがフィットネスに混入する可能性があります。~~

### 5.4 UniversalStrategy の責務過多と実装乖離 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `UniversalStrategy.next()` で `TPSLService.calculate_tpsl_prices()` を正しく呼び出すように修正
> - ATR ベース、ボラティリティベース、適応型、統計的手法に必要な市場データ（OHLC）を渡すように実装
> - ポジションサイジングのキャッシュ問題も解決済み（Section 6.2 参照）

**旧現状:**

- ~~`UniversalStrategy.py` の `next()` メソッド内で、TP/SL 価格の計算が `TPSLService` ではなく単純な四則演算で実装されています。~~
- ~~これにより、`TPSLService` で実装されているはずの高度なリスク計算（ATR ベース、ボラティリティベース）が、実際のバックテスト実行時には**完全に無視**され、単純な固定％または直値のみで実行されています。~~
- ~~`PositionSizingService` の呼び出しが `next()` 内で同期的に行われており、複雑なリスク計算を行うとバックテスト速度が極端に低下する構造になっています。~~

### 5.5 キャッシュ管理の不備 (Memory Leak Risk) ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `IndividualEvaluator` の `_data_cache` を `cachetools.LRUCache` に置換
> - `max_cache_size` パラメータを追加（デフォルト 100 エントリ）
> - `clear_cache()` / `get_cache_info()` メソッドを追加

**旧現状:**

- ~~`IndividualEvaluator` の `_data_cache` が単純な辞書型 (`dict`) で実装されており、エビクションポリシー（容量制限、LRU、TTL など）が存在しません。~~

**~~影響~~:**

- ~~**メモリ枯渇 (OOM)**: 長時間の GA 実行や、多種多様な銘柄・時間足を探索する際にキャッシュが肥大化し続け、サーバーがメモリ不足でクラッシュするリスクがあります。~~

### 5.6 並列処理のゾンビ化リスク ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `ParallelEvaluator` に `use_process_pool` パラメータを追加
> - `ProcessPoolExecutor` 選択時はタイムアウト時にプロセスを強制終了可能
> - Future のキャンセル処理を改善
> - 世代ごとの統計リセット機能を追加

**旧現状:**

- ~~`ParallelEvaluator` は `ThreadPoolExecutor` を使用していますが、Python のスレッドは外部から強制終了（キル）できません。タイムアウト判定はメインスレッド側で行われますが、ワーカースレッド内の処理はバックグラウンドで継続します。~~

**~~影響~~:**

- ~~**リソース枯渇**: タイムアウトした重い個体評価処理が裏で走り続け、CPU リソースを浪費します。世代が進むにつれてゾンビタスクが累積し、システム全体のパフォーマンスが劣化します。~~

### 5.7 類似度計算の精度不足 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - 特徴ベクトル化（`_vectorize_gene`）に指標タイプと条件演算子の情報を追加
> - 「時間軸特性」と「オペランド特性」を追加し、戦略の性質をより詳細に反映
> - KD-Tree による効率的な近傍探索を実装

**旧現状:**

- ~~`FitnessSharing._vectorize_gene` は「指標の数」「条件の数」などのスカラ値のみをベクトル化しています。~~
- ~~「SMA」と「RSI」のような指標の種類の違い（カテゴリカルな差異）が距離計算に反映されていません。~~

**~~影響~~:**

- ~~**多様性の喪失**: 本質的に異なるロジックを持つ戦略でも、パラメータの数値的特徴が似ていれば「同一ニッチ」と誤判定され、ペナルティを受けて淘汰される可能性があります。~~

## 6. 実装上の重大な欠陥 (Critical Implementation Flaws)

### 6.1 Stateful Condition のロジック不備 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `StatefulCondition` クラスに `direction` フィールド（"long" または "short"）を追加
> - `UniversalStrategy` に `_get_stateful_entry_direction()` メソッドを追加
> - `next()` メソッドを修正し、ステートフル条件のみでもエントリーが実行されるように変更
> - `DictConverter` でシリアライズ/デシリアライズに `direction` を含めるように更新
> - TDD によるテストセットを追加完了

**旧現状:**

- ~~`UniversalStrategy.next()` において、`_check_stateful_conditions()` が `True` を返しても、売買方向 (`direction`) を決定するロジックが存在しません。~~
- ~~既存のロジックは `long_signal` または `short_signal` に依存しており、ステートフル条件単独では取引がトリガーされずスキップされます。~~

**現在:**

- `StatefulCondition` に `direction` フィールドがあり、条件成立時の売買方向を指定可能
- ステートフル条件のみが成立した場合でも、正しくエントリーが実行される

**~~影響~~:**

- ~~GA がせっかく生成した「状態依存の高度な戦略」が、バックテスト実行時に**完全に無視**され、学習されません。~~

### 6.2 Position Sizing の静的キャッシュ問題 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `UniversalStrategy._calculate_position_size` からキャッシュロジックを削除
> - エントリー時に毎回、現在の口座残高（`equity`）を参照して計算するように変更
> - これにより複利効果が正しく機能するようになった

**旧現状:**

- ~~`UniversalStrategy._calculate_position_size` が、初回計算結果を `_cached_position_size` に保存し、以後それを使い回しています。~~
- ~~口座残高（Equity）が変動してもポジションサイズ（ロット数）が固定されたままになります。~~

**現在:**

- ポジションサイズはエントリー時に毎回計算される
- `equity` 属性を参照し、口座残高の変動に応じてポジションサイズが動的に調整される

**~~影響~~:**

- ~~**複利効果の喪失**: 利益が出てもポジションサイズが増加せず、単利運用として評価されます。~~
- ~~**リスク管理の無効化**: ドローダウン時にも初期の大きなポジションサイズを維持するため、破産リスクが増大します。~~

## 7. 検証方法論の不足 (Methodological Deficiencies)

### 7.1 堅牢性検証 (Walk-Forward Analysis) の欠如 ✅ **解決済み**

> **解決日: 2025-12-09**
>
> - `GAConfig` に WFA 設定パラメータ（`enable_walk_forward`, `wfa_n_folds`, `wfa_train_ratio`, `wfa_anchored`）を追加
> - `IndividualEvaluator` に `_evaluate_with_walk_forward` メソッドを実装
> - Rolling WFA（スライディングウィンドウ）と Anchored WFA（固定開始点）の両方をサポート
> - 複数フォールドの OOS スコアを平均化して過学習耐性のあるフィットネスを返却

**旧現状:**

- ~~単純なバックテスト（In-Sample）または単純な分割検証（Out-of-Sample）のみ実装されています。~~
- ~~時系列をスライディングさせながら検証する Walk-Forward Analysis が欠如しています。~~

**現在:**

- 3 種類の評価モード:
  - **通常評価**: 全期間で評価
  - **OOS 評価**: トレーニング/テスト分割で評価
  - **WFA 評価**: 複数フォールドでローリング検証

**~~影響~~:**

- ~~**過学習（Overfitting）のリスク**: 特定の期間にたまたまフィットしただけの脆弱な戦略を高評価してしまうリスクが高いです。~~

## 推奨される改善アクション（優先度順）

### Phase 1: クリティカルな修正 (Immediate)

1. ✅ **UniversalStrategy の修正**: `next()` メソッド内で `TPSLService` を正しく呼び出し、遺伝子で指定された計算ロジック（ATR 倍率など）が反映されるように変更する。 **(実装完了: 2025-12-09)**
2. ✅ **UniversalStrategy の PositionSizing 修正**: 重厚な計算を毎ティック行うのではなく、エントリー時のみ、あるいはキャッシングを利用して計算負荷を下げる。 **(実装完了: 2025-12-09)**
3. ✅ **Stateful Condition ロジック修正**: `StatefulCondition` に `direction` フィールドを追加し、`UniversalStrategy.next()` でステートフル条件発火時に適切な売買方向（Long/Short）を決定する。 **(実装完了: 2025-12-09)**
4. ✅ **Position Sizing キャッシュ修正**: キャッシュを削除し、エントリー時に毎回口座残高を参照して計算することで複利効果を有効化。 **(実装完了: 2025-12-09)**

### Phase 2: 機能拡張 (High Impact)

> - ✅ **サンプリング設定の外部化**: `sampling_threshold` / `SAMPLING_RATIO` を `GAConfig` および `FitnessSharing` のインスタンス属性として設定可能に改修。 **(実装完了: 2025-12-09)**
> - ✅ **類似度計算の精度向上**: 特徴ベクトル化（`_vectorize_gene`）に指標タイプと条件演算子（Operator）の情報を追加し、構造的な類似性を考慮するように改修。 **(実装完了: 2025-12-09)**
> - ✅ **高度な特徴量抽出**: フィットネス共有のベクトル化に「時間軸特性（指標期間の平均・最大）」と「オペランド特性（定数/動的比較の比率）」を追加し、戦略の性質をより詳細に反映。 **(実装完了: 2025-12-09)**

### Phase 4: コード品質と保守性 (Maintenance)

8. ✅ **Magic Numbers の排除**: 取引回数 0 や制約違反時のペナルティスコアを `GAConfig` で設定可能にする。 **(実装完了: 2025-12-09)**
9. ✅ **ハードコード制限の解除**: `StrategyGene.MAX_INDICATORS` を `GAConfig.max_indicators` に移行。 **(実装完了: 2025-12-09)**
10. ✅ **設定整合性チェック**: `GASettings` バリデーションに条件数などの整合性チェックを追加。 **(実装完了: 2025-12-09)**
11. ✅ **GA パラメータの完全外部化**: `genetic_operators.py` や `ConditionGenerator` に残る確率係数、条件数、パラメータ変動幅を `GAConfig` に集約し、ハードコード値を排除。 **(実装完了: 2025-12-09)**
12. ✅ **正規化係数の定数化**: `ListEncoder` でのニューラルネットワーク用正規化係数を名前付き定数として管理し、仕様を明確化する。 **(実装完了: 2025-12-09)**
