# オートストラテジー取引回数 0 問題 調査報告書

## 1. 問題の概要

オートストラテジー機能で生成された戦略のバックテスト結果において、取引回数がほぼ毎回 0 回となり、有効な戦略が生成されない。

## 2. 調査結果

コードベースを調査した結果、問題の根本原因は戦略の**売買条件をランダムに生成するロジック**にあることが判明しました。

### 根本原因：比較オペランドのスケール不一致

問題の核心は、`backend/app/core/services/auto_strategy/generators/random_gene_generator.py` 内の条件生成ロジックにあります。

現在の実装では、売買条件を定義する際に、比較対象となる 2 つの要素（オペランド）をランダムに選択しています。このとき、**数値のスケール（桁数や範囲）が全く異なる指標やデータソース同士を比較する**、意味のない条件式が生成されていました。

**具体例：**

以下のような、実質的に機能しない条件式が多数生成されている可能性があります。

- `close` (価格: 例 68,000) `>` `RSI` (0〜100 の指標: 例 70)
  - この条件は、価格が RSI の値を常に上回るため、常に `True` となります。
- `FundingRate` (小さな小数: 例 0.0001) `<` `OpenInterest` (大きな建玉量: 例 50,000,000)
  - この条件も、ほぼ常に `True` となります。

このような条件式では、市場の状況に応じた適切な売買判断ができず、結果としてエントリーシグナルが全く発生しません。

## 3. 問題発生のメカニズム

1.  **無意味な遺伝子の生成:**

    - `random_gene_generator.py` が、上記のようなスケールの合わないオペランドを持つ売買条件（遺伝子）を大量に生成します。

2.  **忠実な戦略クラスへの変換:**

    - `strategy_factory.py` は、この無意味な遺伝子情報から忠実に `backtesting.py` が実行できる戦略クラスを動的に生成します。

3.  **バックテストでの取引不発生:**

    - 生成された戦略クラスでバックテストを実行しても、売買条件が常に`True`または`False`に偏るため、エントリーのタイミングが訪れません。

4.  **適応度 0 点という評価:**

    - `fitness_calculator.py` は、取引回数が 0 回の戦略に対して、ペナルティとして適応度スコアを 0 点と評価します。

5.  **有効な戦略の淘汰:**
    - 遺伝的アルゴリズム（GA）は、適応度の高い個体を次世代に残そうとしますが、評価対象となる個体群のほとんどが 0 点のため、有効な戦略を見つけ出すことができません。
    - 最終的に「最良」として選ばれる戦略も、取引回数 0 回のものになってしまいます。

## 4. その他の潜在的な原因

主たる原因は上記の通りですが、調査の過程で問題を助長している可能性のある、以下の仕様を特定しました。

### データ欠損時のゼロ埋め処理

`backtest_data_service.py` の仕様として、バックテスト期間中に Open Interest (OI)や Funding Rate (FR)のデータが存在しない場合、該当するデータ列の値をすべて `0.0` で埋める処理が行われています。

この仕様は、システムがデータ欠損で停止しないようにする堅牢性のための対策ですが、副作用として取引機会を失わせる可能性があります。

例えば、GA が `FundingRate > 0.0001` のような有効な条件を生成したとしても、テスト期間の Funding Rate データがたまたま欠損していると、`FundingRate` 列はすべて `0.0` となり、この条件は決して満たされません。

## 5. 推奨される解決策

### 対策 1：売買条件生成ロジックの改善（最優先）

問題の根本原因である `random_gene_generator.py` を修正し、より意味のある売買条件を生成できるように改善することが最も重要です。

**具体的な改善案：**

- **オペランドのグループ化:** 指標やデータソースを、その値のスケール（価格ベース、0-100 オシレーター、ゼロ中心オシレーターなど）に基づいてグループ化します。
- **グループ内での比較:** 条件式を生成する際、原則として同じグループに属するオペランド同士を比較するようにロジックを修正します。
- **数値との比較ロジック改善:** オペランドを固定値と比較する場合、そのオペランドのスケールに応じた現実的な範囲の数値を生成するようにします。（例：RSI なら 30 や 70、価格なら価格自身の 0.95 倍など）

### 対策 2：データカバレッジの考慮

GA の評価プロセスにおいて、データが欠損している指標（OI/FR）を含む戦略に対して、何らかのペナルティを与えるか、あるいは評価方法を調整することが考えられます。

**具体的な改善案：**

- **データカバレッジの確認:** バックテストを実行する前に、生成された戦略が使用する指標（OI/FR など）のデータが、テスト期間中にどの程度存在するか（カバレッジ）を確認します。
- **適応度への反映:** データカバレッジが低い指標を使用する戦略に対しては、適応度スコアにペナルティを課すことで、データが十分に存在する信頼性の高い戦略が選ばれやすくなります。

以上の改善を行うことで、取引が実際に発生しうる、より実践的な戦略が生成され、遺伝的アルゴリズムが有効に機能することが期待されます。

**対応済み**

## 6. コードの重複・冗長性に関する改善提案

これまでのファイル分析に基づき、オートストラテジー関連コードにおける重複や冗長な部分、および改善の余地がある点を以下にまとめます。

### 6.2. `backend/app/core/services/auto_strategy/services/auto_strategy_service.py` における改善の余地

- **データベースセッションの管理**:
  - **現状**: `_init_services` と `_save_experiment_result` で `SessionLocal()` を使用し、`db.close()` を `finally` で呼び出している。これは正しいパターンだが、もし複数のメソッドで頻繁に DB セッションを必要とする場合、FastAPI の依存性注入 (`Depends(get_db)`) をサービス層でも活用するか、コンテキストマネージャ (`with SessionLocal() as db:`) を利用することで、コードの重複を減らし、テスト容易性を向上させることができます。
- **`_save_experiment_result` 内のバックテスト再実行のエラーハンドリング**:
  - **現状**: 最良戦略のバックテスト結果を詳細に保存する際の `backtest_service.run_backtest` 呼び出しが `try...except` で囲まれており、エラーが発生しても処理が継続されるが、エラーが上位に伝播しない。
  - **改善提案**: エラーをログに記録するだけでなく、必要に応じて `_save_experiment_result` メソッドの呼び出し元にエラーを通知するメカニズム（例: 戻り値で成功/失敗を示す、特定の例外を再 raise する）を検討することで、デバッグやエラー追跡が容易になります。

### 6.3. `backend/app/core/strategies/macd_strategy.py` における重複と改善

- **`MACDStrategy` と `BaseStrategy` の継承関係**:
  - **現状**: `MACDStrategy` は `backtesting.Strategy` を直接継承しており、`BaseStrategy` を継承していない。そのため、`BaseStrategy` で定義されている共通の初期化ロジック（例: `_strategy_name`, `_parameters` の設定）やユーティリティメソッドが利用されていない。
  - **改善提案**: `MACDStrategy` を `BaseStrategy` から継承するように変更することで、共通機能の再利用性を高め、コードの重複を削減できます。これにより、`MACDStrategy` の `__init__` メソッドをより簡潔にできます。
- **パラメータのエイリアス `n1`, `n2`**:
  - **現状**: `fast_period` と `slow_period` のエイリアスとして `n1`, `n2` が定義されており、`init` メソッド内で同期処理が行われている。コメントには後方互換性のためとある。
  - **改善提案**: もし後方互換性の必要がなければ、これらのエイリアスと同期ロジックを削除することで、コードを簡潔にできます。
- **`MACDScalpingStrategy` の利確・損切りロジックの共通化**:
  - **現状**: `MACDScalpingStrategy` の `next` メソッド内で利確・損切りロジックが直接実装されている。
  - **改善提案**: もし他の戦略でも同様の利確・損切りロジックを共通で利用したい場合、`BaseStrategy` に共通のメソッド（例: `apply_risk_management`）として切り出すことを検討できます。これにより、各戦略の `next` メソッドは売買シグナル生成に集中し、リスク管理ロジックは共通化されます。
